# Comparing `tmp/archcraftsman-3.5.9-py3-none-any.whl.zip` & `tmp/archcraftsman-4.0.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,57 +1,66 @@
-Zip file size: 100974 bytes, number of entries: 55
--rw-r--r--  2.0 unx      732 b- defN 23-Mar-24 22:08 archcraftsman/__init__.py
--rw-r--r--  2.0 unx    11926 b- defN 23-Mar-29 19:26 archcraftsman/autopart.py
--rw-r--r--  2.0 unx    11771 b- defN 23-Mar-29 19:26 archcraftsman/basesetup.py
--rw-r--r--  2.0 unx     4345 b- defN 23-Mar-29 19:26 archcraftsman/disk.py
--rw-r--r--  2.0 unx     2580 b- defN 23-Mar-29 19:26 archcraftsman/globalargs.py
--rw-r--r--  2.0 unx     2233 b- defN 23-Mar-24 22:08 archcraftsman/i18n.py
--rw-r--r--  2.0 unx    13132 b- defN 23-Mar-29 19:26 archcraftsman/installer.py
--rw-r--r--  2.0 unx     7450 b- defN 23-Mar-29 19:26 archcraftsman/manualpart.py
--rw-r--r--  2.0 unx     3037 b- defN 23-Mar-24 22:08 archcraftsman/options.py
--rw-r--r--  2.0 unx     3378 b- defN 23-Mar-29 19:26 archcraftsman/packages.py
--rw-r--r--  2.0 unx    10602 b- defN 23-Mar-29 19:26 archcraftsman/partition.py
--rw-r--r--  2.0 unx     3470 b- defN 23-Mar-24 22:08 archcraftsman/partitioninginfo.py
--rw-r--r--  2.0 unx     3254 b- defN 23-Mar-29 18:22 archcraftsman/prelaunchinfo.py
--rw-r--r--  2.0 unx     4938 b- defN 23-Mar-24 22:08 archcraftsman/shell.py
--rw-r--r--  2.0 unx     1245 b- defN 23-Mar-24 22:08 archcraftsman/systeminfo.py
--rw-r--r--  2.0 unx    12423 b- defN 23-Mar-29 19:26 archcraftsman/utils.py
+Zip file size: 98940 bytes, number of entries: 64
+-rw-r--r--  2.0 unx      732 b- defN 23-Apr-20 21:57 archcraftsman/__init__.py
+-rw-r--r--  2.0 unx      828 b- defN 23-May-03 18:09 archcraftsman/__main__.py
+-rw-r--r--  2.0 unx     1904 b- defN 23-May-03 18:09 archcraftsman/arguments.py
+-rw-r--r--  2.0 unx    11383 b- defN 23-May-05 19:14 archcraftsman/autopart.py
+-rw-r--r--  2.0 unx     6720 b- defN 23-May-03 18:09 archcraftsman/base.py
+-rw-r--r--  2.0 unx    12635 b- defN 23-May-05 19:14 archcraftsman/basesetup.py
+-rw-r--r--  2.0 unx     5314 b- defN 23-May-03 18:09 archcraftsman/config.py
+-rw-r--r--  2.0 unx     4444 b- defN 23-May-03 18:09 archcraftsman/disk.py
+-rw-r--r--  2.0 unx     1449 b- defN 23-May-03 18:09 archcraftsman/i18n.py
+-rw-r--r--  2.0 unx     1281 b- defN 23-May-03 18:09 archcraftsman/info.py
+-rw-r--r--  2.0 unx    11235 b- defN 23-May-05 19:14 archcraftsman/installer.py
+-rw-r--r--  2.0 unx     7320 b- defN 23-May-05 19:14 archcraftsman/manualpart.py
+-rw-r--r--  2.0 unx     3984 b- defN 23-May-03 18:09 archcraftsman/options.py
+-rw-r--r--  2.0 unx     3335 b- defN 23-May-03 18:09 archcraftsman/packages.py
+-rw-r--r--  2.0 unx    10496 b- defN 23-May-05 19:14 archcraftsman/partition.py
+-rw-r--r--  2.0 unx     4299 b- defN 23-May-03 18:09 archcraftsman/partitioninginfo.py
+-rw-r--r--  2.0 unx     3638 b- defN 23-May-03 18:09 archcraftsman/prelaunchinfo.py
+-rw-r--r--  2.0 unx     6180 b- defN 23-May-05 19:14 archcraftsman/shell.py
+-rw-r--r--  2.0 unx     3116 b- defN 23-May-03 18:09 archcraftsman/systeminfo.py
+-rw-r--r--  2.0 unx     8407 b- defN 23-May-05 19:14 archcraftsman/utils.py
 -rw-r--r--  2.0 unx      732 b- defN 23-Mar-24 22:08 archcraftsman/bundles/__init__.py
--rw-r--r--  2.0 unx     2616 b- defN 23-Mar-29 18:38 archcraftsman/bundles/budgie.py
--rw-r--r--  2.0 unx     1485 b- defN 23-Mar-24 22:08 archcraftsman/bundles/bundle.py
--rw-r--r--  2.0 unx     2765 b- defN 23-Mar-24 22:08 archcraftsman/bundles/cinnamon.py
--rw-r--r--  2.0 unx     1893 b- defN 23-Mar-24 23:21 archcraftsman/bundles/copyacm.py
--rw-r--r--  2.0 unx     1997 b- defN 23-Mar-24 22:08 archcraftsman/bundles/cups.py
--rw-r--r--  2.0 unx     2287 b- defN 23-Mar-24 22:08 archcraftsman/bundles/cutefish.py
--rw-r--r--  2.0 unx     2463 b- defN 23-Mar-24 22:08 archcraftsman/bundles/deepin.py
--rw-r--r--  2.0 unx     1989 b- defN 23-Mar-24 22:08 archcraftsman/bundles/enlightenment.py
--rw-r--r--  2.0 unx     2294 b- defN 23-Mar-24 22:08 archcraftsman/bundles/gnome.py
--rw-r--r--  2.0 unx     1720 b- defN 23-Mar-24 22:08 archcraftsman/bundles/grmlzsh.py
--rw-r--r--  2.0 unx     4284 b- defN 23-Mar-29 19:26 archcraftsman/bundles/grub.py
--rw-r--r--  2.0 unx     2063 b- defN 23-Mar-24 22:08 archcraftsman/bundles/i3.py
--rw-r--r--  2.0 unx     1771 b- defN 23-Mar-24 22:08 archcraftsman/bundles/iwd.py
--rw-r--r--  2.0 unx     2157 b- defN 23-Mar-24 22:08 archcraftsman/bundles/linux.py
--rw-r--r--  2.0 unx     2545 b- defN 23-Mar-24 22:08 archcraftsman/bundles/lxqt.py
--rw-r--r--  2.0 unx     1640 b- defN 23-Mar-24 22:08 archcraftsman/bundles/mainfilesystems.py
--rw-r--r--  2.0 unx     1931 b- defN 23-Mar-24 22:08 archcraftsman/bundles/mainfonts.py
--rw-r--r--  2.0 unx     2943 b- defN 23-Mar-24 22:08 archcraftsman/bundles/mate.py
--rw-r--r--  2.0 unx     2265 b- defN 23-Mar-29 18:55 archcraftsman/bundles/microcodes.py
--rw-r--r--  2.0 unx     1988 b- defN 23-Mar-24 22:08 archcraftsman/bundles/networkmanager.py
--rw-r--r--  2.0 unx     1391 b- defN 23-Mar-24 22:08 archcraftsman/bundles/nvidia.py
--rw-r--r--  2.0 unx     1474 b- defN 23-Mar-24 22:08 archcraftsman/bundles/pipewire.py
--rw-r--r--  2.0 unx     3001 b- defN 23-Mar-24 22:08 archcraftsman/bundles/plasma.py
--rw-r--r--  2.0 unx     2629 b- defN 23-Mar-24 22:08 archcraftsman/bundles/sway.py
--rw-r--r--  2.0 unx     1826 b- defN 23-Mar-24 22:08 archcraftsman/bundles/systemdnet.py
--rw-r--r--  2.0 unx     1646 b- defN 23-Mar-24 22:08 archcraftsman/bundles/terminus.py
--rw-r--r--  2.0 unx     5241 b- defN 23-Mar-24 22:08 archcraftsman/bundles/utils.py
--rw-r--r--  2.0 unx     2974 b- defN 23-Mar-24 22:08 archcraftsman/bundles/xfce.py
--rw-r--r--  2.0 unx     1828 b- defN 23-Mar-24 22:08 archcraftsman/bundles/zram.py
+-rw-r--r--  2.0 unx     2342 b- defN 23-May-03 18:09 archcraftsman/bundles/budgie.py
+-rw-r--r--  2.0 unx     1424 b- defN 23-May-03 18:09 archcraftsman/bundles/bundle.py
+-rw-r--r--  2.0 unx     2491 b- defN 23-May-03 18:09 archcraftsman/bundles/cinnamon.py
+-rw-r--r--  2.0 unx     1701 b- defN 23-May-03 18:09 archcraftsman/bundles/copyacm.py
+-rw-r--r--  2.0 unx     1653 b- defN 23-May-03 18:09 archcraftsman/bundles/cups.py
+-rw-r--r--  2.0 unx     2013 b- defN 23-May-03 18:09 archcraftsman/bundles/cutefish.py
+-rw-r--r--  2.0 unx     2250 b- defN 23-May-03 18:09 archcraftsman/bundles/deepin.py
+-rw-r--r--  2.0 unx     1684 b- defN 23-May-03 18:09 archcraftsman/bundles/enlightenment.py
+-rw-r--r--  2.0 unx     1066 b- defN 23-May-03 18:09 archcraftsman/bundles/generateconfig.py
+-rw-r--r--  2.0 unx     2020 b- defN 23-May-03 18:09 archcraftsman/bundles/gnome.py
+-rw-r--r--  2.0 unx     1415 b- defN 23-May-03 18:09 archcraftsman/bundles/grmlzsh.py
+-rw-r--r--  2.0 unx     4149 b- defN 23-May-03 18:09 archcraftsman/bundles/grub.py
+-rw-r--r--  2.0 unx     1758 b- defN 23-May-03 18:09 archcraftsman/bundles/i3.py
+-rw-r--r--  2.0 unx     1380 b- defN 23-May-03 18:09 archcraftsman/bundles/iwd.py
+-rw-r--r--  2.0 unx     1985 b- defN 23-May-03 18:09 archcraftsman/bundles/linux.py
+-rw-r--r--  2.0 unx     2271 b- defN 23-May-03 18:09 archcraftsman/bundles/lxqt.py
+-rw-r--r--  2.0 unx     1543 b- defN 23-May-03 18:09 archcraftsman/bundles/mainfilesystems.py
+-rw-r--r--  2.0 unx     1826 b- defN 23-May-05 20:20 archcraftsman/bundles/mainfonts.py
+-rw-r--r--  2.0 unx     2728 b- defN 23-May-03 18:09 archcraftsman/bundles/mate.py
+-rw-r--r--  2.0 unx     2126 b- defN 23-May-03 18:09 archcraftsman/bundles/microcodes.py
+-rw-r--r--  2.0 unx     1661 b- defN 23-May-03 18:09 archcraftsman/bundles/networkmanager.py
+-rw-r--r--  2.0 unx     1381 b- defN 23-May-03 18:09 archcraftsman/bundles/nvidia.py
+-rw-r--r--  2.0 unx     1377 b- defN 23-May-03 18:09 archcraftsman/bundles/pipewire.py
+-rw-r--r--  2.0 unx     2807 b- defN 23-May-03 18:09 archcraftsman/bundles/plasma.py
+-rw-r--r--  2.0 unx     2332 b- defN 23-May-03 18:09 archcraftsman/bundles/sway.py
+-rw-r--r--  2.0 unx     1482 b- defN 23-May-03 18:09 archcraftsman/bundles/systemdnet.py
+-rw-r--r--  2.0 unx     1341 b- defN 23-May-03 18:09 archcraftsman/bundles/terminus.py
+-rw-r--r--  2.0 unx     5493 b- defN 23-May-05 19:14 archcraftsman/bundles/utils.py
+-rw-r--r--  2.0 unx     2700 b- defN 23-May-03 18:09 archcraftsman/bundles/xfce.py
+-rw-r--r--  2.0 unx     1427 b- defN 23-May-03 18:09 archcraftsman/bundles/yay.py
+-rw-r--r--  2.0 unx     1484 b- defN 23-May-03 18:09 archcraftsman/bundles/zram.py
 -rw-r--r--  2.0 unx      732 b- defN 23-Mar-25 00:46 archcraftsman/locales/__init__.py
--rw-r--r--  2.0 unx    28630 b- defN 23-Mar-24 23:21 archcraftsman/locales/fr.po
--rw-r--r--  2.0 unx    35149 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx    42432 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/METADATA
--rw-r--r--  2.0 unx      704 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/NOTICES
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       63 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     4775 b- defN 23-Mar-29 19:31 archcraftsman-3.5.9.dist-info/RECORD
-55 files, 276945 bytes uncompressed, 93380 bytes compressed:  66.3%
+-rw-r--r--  2.0 unx    29220 b- defN 23-May-03 18:09 archcraftsman/locales/french.po
+-rw-r--r--  2.0 unx      732 b- defN 23-May-03 18:09 archcraftsman/test/__init__.py
+-rw-r--r--  2.0 unx    10466 b- defN 23-May-05 19:14 archcraftsman/test/test_base.py
+-rw-r--r--  2.0 unx     2858 b- defN 23-May-05 19:14 archcraftsman/test/test_utils.py
+-rw-r--r--  2.0 unx    35149 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    10484 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      704 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/NOTICES
+-rw-r--r--  2.0 unx       92 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       63 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     5539 b- defN 23-May-06 19:17 archcraftsman-4.0.1.dist-info/RECORD
+64 files, 268795 bytes uncompressed, 90156 bytes compressed:  66.5%
```

## zipnote {}

```diff
@@ -1,25 +1,37 @@
 Filename: archcraftsman/__init__.py
 Comment: 
 
+Filename: archcraftsman/__main__.py
+Comment: 
+
+Filename: archcraftsman/arguments.py
+Comment: 
+
 Filename: archcraftsman/autopart.py
 Comment: 
 
+Filename: archcraftsman/base.py
+Comment: 
+
 Filename: archcraftsman/basesetup.py
 Comment: 
 
-Filename: archcraftsman/disk.py
+Filename: archcraftsman/config.py
 Comment: 
 
-Filename: archcraftsman/globalargs.py
+Filename: archcraftsman/disk.py
 Comment: 
 
 Filename: archcraftsman/i18n.py
 Comment: 
 
+Filename: archcraftsman/info.py
+Comment: 
+
 Filename: archcraftsman/installer.py
 Comment: 
 
 Filename: archcraftsman/manualpart.py
 Comment: 
 
 Filename: archcraftsman/options.py
@@ -69,14 +81,17 @@
 
 Filename: archcraftsman/bundles/deepin.py
 Comment: 
 
 Filename: archcraftsman/bundles/enlightenment.py
 Comment: 
 
+Filename: archcraftsman/bundles/generateconfig.py
+Comment: 
+
 Filename: archcraftsman/bundles/gnome.py
 Comment: 
 
 Filename: archcraftsman/bundles/grmlzsh.py
 Comment: 
 
 Filename: archcraftsman/bundles/grub.py
@@ -129,38 +144,50 @@
 
 Filename: archcraftsman/bundles/utils.py
 Comment: 
 
 Filename: archcraftsman/bundles/xfce.py
 Comment: 
 
+Filename: archcraftsman/bundles/yay.py
+Comment: 
+
 Filename: archcraftsman/bundles/zram.py
 Comment: 
 
 Filename: archcraftsman/locales/__init__.py
 Comment: 
 
-Filename: archcraftsman/locales/fr.po
+Filename: archcraftsman/locales/french.po
+Comment: 
+
+Filename: archcraftsman/test/__init__.py
+Comment: 
+
+Filename: archcraftsman/test/test_base.py
+Comment: 
+
+Filename: archcraftsman/test/test_utils.py
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/LICENSE.txt
+Filename: archcraftsman-4.0.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/METADATA
+Filename: archcraftsman-4.0.1.dist-info/METADATA
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/NOTICES
+Filename: archcraftsman-4.0.1.dist-info/NOTICES
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/WHEEL
+Filename: archcraftsman-4.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/entry_points.txt
+Filename: archcraftsman-4.0.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/top_level.txt
+Filename: archcraftsman-4.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: archcraftsman-3.5.9.dist-info/RECORD
+Filename: archcraftsman-4.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## archcraftsman/autopart.py

```diff
@@ -13,59 +13,47 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The automatic partitioning system module
 """
+from archcraftsman import info
+from archcraftsman.base import execute, is_bios, print_step, print_sub_step
 from archcraftsman.disk import Disk
-from archcraftsman.i18n import I18n
+from archcraftsman.i18n import _
 from archcraftsman.options import FSFormats, PartTypes, SwapTypes
 from archcraftsman.partition import Partition
-from archcraftsman.partitioninginfo import PartitioningInfo
 from archcraftsman.utils import (
     ask_drive,
     ask_format_type,
-    execute,
     from_iec,
-    is_bios,
-    print_step,
-    print_sub_step,
     prompt_bool,
     prompt_option,
     to_iec,
 )
 
-_ = I18n().gettext
 
-
-def auto_partitioning() -> tuple[bool, PartitioningInfo]:
+def auto_partitioning() -> bool:
     """
     The method to proceed to the automatic partitioning.
     """
-    partitioning_info = PartitioningInfo()
     user_answer = False
     while not user_answer:
         print_step(_("Automatic partitioning :"))
         execute("fdisk -l", force=True, sudo=True)
-        target_disk = ask_drive(
-            _(
-                "On which drive should Archlinux be installed ? (type the entire name, for example '/dev/sda') : "
-            ),
-            _("The target drive '%s' doesn't exist."),
-            _("Detected drives :"),
-        )
-        partitioning_info.main_disk = target_disk
+        target_disk = ask_drive()
+        info.ai.partitioning_info.main_disk = target_disk
         disk = Disk(target_disk)
         efi_partition = disk.get_efi_partition()
         if (
             not is_bios()
             and len(disk.partitions) > 0
             and efi_partition.path
-            and efi_partition.fs_type == "vfat"
+            and efi_partition.fs_type() == "vfat"
             and disk.free_space > from_iec("32G")
         ):
             want_dual_boot = prompt_bool(
                 _("Do you want to install Arch Linux next to other systems ?")
             )
         else:
             want_dual_boot = False
@@ -95,36 +83,35 @@
         if want_dual_boot:
             root_size = to_iec(int(disk.free_space / 4))
             swap_size = to_iec(int(disk.free_space / 32))
         else:
             root_size = to_iec(int(disk.total / 4))
             swap_size = to_iec(int(disk.total / 32))
         if swap_type == SwapTypes.NONE:
-            swap_size = None
-        partitioning_info.swapfile_size = swap_size
+            swap_size = ""
+        info.ai.partitioning_info.swapfile_size = swap_size
         auto_part_str = ""
         index = 0
         if is_bios():
             # DOS LABEL
             auto_part_str += "o\n"  # Create a new empty DOS partition table
             # BOOT
             auto_part_str += "n\n"  # Add a new partition
             auto_part_str += "p\n"  # Partition primary (Accept default: primary)
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             auto_part_str += " \n"  # First sector (Accept default: 1)
-            auto_part_str += "+1G\n"  # Last sector (Accept default: varies)
+            auto_part_str += "+2G\n"  # Last sector (Accept default: varies)
             auto_part_str += "a\n"  # Toggle bootable flag
-            partitioning_info.partitions.append(
+            info.ai.partitioning_info.partitions.append(
                 Partition(
                     index=index,
-                    part_type=PartTypes.OTHER,
+                    part_type=PartTypes.BOOT,
                     part_mount_point="/boot",
                     part_format=True,
                     part_format_type=part_format_type,
-                    compute=False,
                 )
             )
             index += 1
         else:
             if not want_dual_boot:
                 # GPT LABEL
                 auto_part_str += "g\n"  # Create a new empty GPT partition table
@@ -132,33 +119,31 @@
                 auto_part_str += "n\n"  # Add a new partition
                 auto_part_str += " \n"  # Partition number (Accept default: auto)
                 auto_part_str += " \n"  # First sector (Accept default: 1)
                 auto_part_str += "+512M\n"  # Last sector (Accept default: varies)
                 auto_part_str += "t\n"  # Change partition type
                 auto_part_str += " \n"  # Partition number (Accept default: auto)
                 auto_part_str += "1\n"  # Type EFI System
-                partitioning_info.partitions.append(
+                info.ai.partitioning_info.partitions.append(
                     Partition(
                         index=index,
                         part_type=PartTypes.EFI,
                         part_mount_point="/boot/efi",
                         part_format=True,
                         part_format_type=FSFormats.VFAT,
-                        compute=False,
                     )
                 )
                 index += 1
             else:
-                partitioning_info.partitions.append(
+                info.ai.partitioning_info.partitions.append(
                     Partition(
                         index=index,
                         part_type=PartTypes.EFI,
                         part_mount_point="/boot/efi",
                         part_format=False,
-                        compute=False,
                     )
                 )
                 index += len(disk.partitions)
         if swap_type == SwapTypes.PARTITION:
             # SWAP
             auto_part_str += "n\n"  # Add a new partition
             if is_bios():
@@ -168,123 +153,118 @@
             auto_part_str += f"+{swap_size}\n"  # Last sector (Accept default: varies)
             auto_part_str += "t\n"  # Change partition type
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             if is_bios():
                 auto_part_str += "82\n"  # Type Linux Swap
             else:
                 auto_part_str += "19\n"  # Type Linux Swap
-            partitioning_info.partitions.append(
-                Partition(index=index, part_type=PartTypes.SWAP, compute=False)
+            info.ai.partitioning_info.partitions.append(
+                Partition(index=index, part_type=PartTypes.SWAP)
             )
             index += 1
-        if root_block_name:
+        if root_block_name and not any(
+            p.part_type == PartTypes.BOOT for p in info.ai.partitioning_info.partitions
+        ):
             # BOOT
             auto_part_str += "n\n"  # Add a new partition
             if is_bios():
                 auto_part_str += "p\n"  # Partition primary (Accept default: primary)
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += "+2G\n"  # Last sector (Accept default: varies)
-            partitioning_info.partitions.append(
+            info.ai.partitioning_info.partitions.append(
                 Partition(
                     index=index,
                     part_type=PartTypes.BOOT,
                     part_mount_point="/boot",
                     part_format=True,
                     part_format_type=part_format_type,
-                    compute=False,
                 )
             )
             index += 1
         if want_home:
             # ROOT
             auto_part_str += "n\n"  # Add a new partition
             if is_bios():
                 auto_part_str += "p\n"  # Partition primary (Accept default: primary)
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += f"+{root_size}\n"  # Last sector (Accept default: varies)
-            partitioning_info.partitions.append(
+            info.ai.partitioning_info.partitions.append(
                 Partition(
                     index=index,
                     part_type=PartTypes.ROOT,
                     part_mount_point="/",
                     part_format=True,
                     part_format_type=part_format_type,
-                    compute=False,
                 )
             )
             index += 1
             # HOME
             auto_part_str += "n\n"  # Add a new partition
             if is_bios():
                 auto_part_str += "p\n"  # Partition primary (Accept default: primary)
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += " \n"  # Last sector (Accept default: varies)
-            partitioning_info.partitions.append(
+            info.ai.partitioning_info.partitions.append(
                 Partition(
                     index=index,
                     part_type=PartTypes.HOME,
                     part_mount_point="/home",
                     part_format=True,
                     part_format_type=part_format_type,
-                    compute=False,
                 )
             )
             index += 1
         else:
             # ROOT
             auto_part_str += "n\n"  # Add a new partition
             if is_bios():
                 auto_part_str += "p\n"  # Partition primary (Accept default: primary)
             auto_part_str += " \n"  # Partition number (Accept default: auto)
             auto_part_str += " \n"  # First sector (Accept default: 1)
             auto_part_str += " \n"  # Last sector (Accept default: varies)
-            partitioning_info.partitions.append(
+            info.ai.partitioning_info.partitions.append(
                 Partition(
                     index=index,
                     part_type=PartTypes.ROOT,
                     part_mount_point="/",
                     part_format=True,
                     part_format_type=part_format_type,
-                    compute=False,
                 )
             )
             index += 1
         # WRITE
         auto_part_str += "w\n"
 
-        for partition in partitioning_info.partitions:
+        for partition in info.ai.partitioning_info.partitions:
             if partition.part_type == PartTypes.ROOT and root_block_name is not None:
                 partition.encrypted = True
                 partition.block_name = root_block_name
             if partition.part_type == PartTypes.HOME and home_block_name is not None:
                 partition.encrypted = True
                 partition.block_name = home_block_name
 
         print_step(_("Summary of choices :"))
-        for partition in partitioning_info.partitions:
+        for partition in info.ai.partitioning_info.partitions:
             print_sub_step(partition.summary())
         if swap_type == SwapTypes.FILE and swap_size is not None:
             print_sub_step(_("Swapfile size : %s") % swap_size)
         user_answer = prompt_bool(_("Is the information correct ?"), default=False)
         if not user_answer:
             want_to_change = prompt_bool(
                 _("Do you want to change the partitioning mode ?"), default=False
             )
             if want_to_change:
-                return False, partitioning_info
-            partitioning_info.partitions.clear()
+                return False
+            info.ai.partitioning_info.partitions.clear()
         else:
             execute(f'echo -e "{auto_part_str}" | fdisk "{target_disk}" &>/dev/null')
 
-            for partition in partitioning_info.partitions:
+            for partition in info.ai.partitioning_info.partitions:
                 partition.build_partition_name(target_disk)
 
-                if partition.part_type == PartTypes.ROOT:
-                    partitioning_info.root_partition = partition
-
-                if partition not in partitioning_info.partitions:
-                    partitioning_info.partitions.append(partition)
+                if partition not in info.ai.partitioning_info.partitions:
+                    info.ai.partitioning_info.partitions.append(partition)
 
-    return True, partitioning_info
+    return True
```

## archcraftsman/basesetup.py

```diff
@@ -15,290 +15,328 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The system setup module
 """
 import json
 import re
+import sys
+from subprocess import CalledProcessError
 from urllib.request import urlopen
 
+from archcraftsman import arguments, info
+from archcraftsman.base import (
+    elevate,
+    execute,
+    is_bios,
+    print_error,
+    print_step,
+    print_sub_step,
+    prompt_ln,
+)
 from archcraftsman.bundles.bundle import Bundle
 from archcraftsman.bundles.copyacm import CopyACM
 from archcraftsman.bundles.cups import Cups
 from archcraftsman.bundles.grmlzsh import GrmlZsh
 from archcraftsman.bundles.grub import Grub
-from archcraftsman.bundles.mainfilesystems import get_main_file_systems, MainFileSystems
-from archcraftsman.bundles.mainfonts import get_main_fonts, MainFonts
+from archcraftsman.bundles.mainfilesystems import MainFileSystems, get_main_file_systems
+from archcraftsman.bundles.mainfonts import MainFonts, get_main_fonts
 from archcraftsman.bundles.microcodes import Microcodes
 from archcraftsman.bundles.nvidia import NvidiaDriver
 from archcraftsman.bundles.pipewire import PipeWire
 from archcraftsman.bundles.terminus import TerminusFont
 from archcraftsman.bundles.utils import prompt_bundle
 from archcraftsman.bundles.zram import Zram
-from archcraftsman.i18n import I18n
-from archcraftsman.options import Kernels, Desktops, Bundles, BootLoaders, Network
+from archcraftsman.config import deserialize
+from archcraftsman.i18n import _
+from archcraftsman.options import (
+    BootLoaders,
+    Bundles,
+    Desktops,
+    Kernels,
+    Languages,
+    Network,
+)
 from archcraftsman.packages import Packages
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
+from archcraftsman.prelaunchinfo import parse_detected_language
 from archcraftsman.utils import (
-    print_error,
-    print_step,
-    print_sub_step,
-    prompt_ln,
-    prompt_bool,
+    ask_keymap,
     ask_password,
-    execute,
-    is_bios,
+    generate_translations,
+    prompt_bool,
+    prompt_option,
 )
 
-_ = I18n().gettext
 
-
-def initial_setup(shell_mode: bool = False) -> PreLaunchInfo:
+def initial_setup(shell_mode: bool = False):
     """
     The method to get environment configurations from the user.
     """
     print_sub_step(_("Querying IP geolocation information..."))
     with urlopen("https://ipapi.co/json") as response:
         geoip_info = json.loads(response.read())
     detected_language = str(geoip_info["languages"]).split(",", maxsplit=1)[0]
     detected_timezone = geoip_info["timezone"]
 
-    pre_launch_info = PreLaunchInfo()
-    if detected_language == "fr-FR":
-        default_language = "FR"
-    else:
-        default_language = "EN"
+    default_language = parse_detected_language(detected_language)
 
     if detected_language == "fr-FR":
         default_keymap = "fr-latin9"
     else:
         default_keymap = "de-latin1"
 
-    pre_launch_info.detected_timezone = detected_timezone
-    pre_launch_info.global_language = default_language
-    pre_launch_info.keymap = default_keymap
+    if not arguments.config():
+        info.ai.pre_launch_info.detected_timezone = detected_timezone
+        info.ai.pre_launch_info.global_language = default_language
+        info.ai.pre_launch_info.keymap = default_keymap
 
-    user_answer = shell_mode
+    user_answer = shell_mode or arguments.config()
     while not user_answer:
         print_step(_("Welcome to ArchCraftsman !"))
         if is_bios():
             print_error(
                 _(
                     "BIOS detected ! The script will act accordingly. Don't forget to select a DOS label type before "
                     "partitioning."
                 )
             )
 
         print_step(_("Environment configuration : "), clear=False)
 
-        supported_global_languages = ["FR", "EN"]
+        global_language = prompt_option(
+            _("Choose your installation's language (%s) : "),
+            _("Global language '%s' is not supported."),
+            Languages,
+            supported_msg=_("Supported languages : "),
+            default=default_language,
+        )
+        if global_language:
+            info.ai.pre_launch_info.global_language = global_language
 
-        print_step(_("Supported languages : "), clear=False)
-        print_sub_step(", ".join(supported_global_languages))
-        print("")
-        global_language_ok = False
-        while not global_language_ok:
-            pre_launch_info.global_language = prompt_ln(
-                _("Choose your installation's language (%s) : ") % default_language,
-                default=default_language,
-            ).upper()
-            if pre_launch_info.global_language in supported_global_languages:
-                global_language_ok = True
-            else:
-                print_error(
-                    _("Global language '%s' is not supported.")
-                    % pre_launch_info.global_language,
-                    do_pause=False,
-                )
-                continue
-
-        keymap_ok = False
-        while not keymap_ok:
-            pre_launch_info.keymap = prompt_ln(
-                _("Type your installation's keymap (%s) : ") % default_keymap,
-                default=default_keymap,
-            )
-            if execute(
-                f'localectl list-keymaps | grep "^{pre_launch_info.keymap}$" &>/dev/null'
-            ):
-                keymap_ok = True
-            else:
-                print_error(_("Keymap %s doesn't exist.") % pre_launch_info.keymap)
-                continue
+        info.ai.pre_launch_info.keymap = ask_keymap(default_keymap)
 
         print_step(_("Summary of choices :"), clear=False)
         print_sub_step(
-            _("Your installation's language : %s") % pre_launch_info.global_language
+            _("Your installation's language : %s")
+            % info.ai.pre_launch_info.global_language
+        )
+        print_sub_step(
+            _("Your installation's keymap : %s") % info.ai.pre_launch_info.keymap
         )
-        print_sub_step(_("Your installation's keymap : %s") % pre_launch_info.keymap)
         user_answer = prompt_bool(_("Is the information correct ?"), default=False)
+    generate_translations(info.ai.pre_launch_info.global_language)
     if not shell_mode:
-        pre_launch_info.setup_locale()
-    return pre_launch_info
+        info.ai.pre_launch_info.setup_locale()
+
+
+def pre_launch(shell_mode: bool = False):
+    """
+    A pre-launch steps method.
+    """
+    try:
+        if not elevate():
+            print_error(_("This script must be run as root."), do_pause=False)
+            sys.exit(1)
+
+        if arguments.config():
+            deserialize(arguments.config())
+
+        print_step(_("Running pre-launch steps : "), clear=False)
+
+        if not shell_mode:
+            execute('sed -i "s|#Color|Color|g" /etc/pacman.conf')
+            execute(
+                'sed -i "s|#ParallelDownloads = 5|ParallelDownloads = 5\\nDisableDownloadTimeout|g" /etc/pacman.conf'
+            )
+
+            print_sub_step(_("Synchronising repositories..."))
+            execute("pacman -Sy &>/dev/null")
+            Packages()
+
+        initial_setup(shell_mode)
+    except KeyboardInterrupt:
+        print_error(_("Script execution interrupted by the user !"), do_pause=False)
+        sys.exit(1)
+    except CalledProcessError as exception:
+        print_error(
+            _("A subprocess execution failed ! See the following error: %s")
+            % exception,
+            do_pause=False,
+        )
+        sys.exit(1)
+    except EOFError:
+        sys.exit(1)
 
 
-def setup_system(detected_timezone) -> SystemInfo:
+def setup_system():
     """
     The method to get system configurations from the user.
     """
-    system_setup = SystemInfo()
     user_answer = False
     while not user_answer:
         print_step(_("System configuration : "))
-        system_setup.hostname = prompt_ln(
+        info.ai.system_info.hostname = prompt_ln(
             _("What will be your hostname (archlinux) : "), default="archlinux"
         )
-        system_setup.bundles = []
+        info.ai.system_info.bundles = []
+
+        info.ai.system_info.bundles.append(
+            prompt_bundle(
+                _("Choose your kernel (%s) : "),
+                _("Kernel '%s' is not supported."),
+                Kernels,
+                _("Supported kernels : "),
+                Kernels.CURRENT,
+            )
+        )
+
+        info.ai.system_info.bundles.append(
+            prompt_bundle(
+                _("Install a desktop environment ? (%s) : "),
+                _("Desktop environment '%s' is not supported."),
+                Desktops,
+                _("Supported desktop environments : "),
+                Desktops.NONE,
+            )
+        )
 
-        system_setup.kernel = prompt_bundle(
-            _("Choose your kernel (%s) : "),
-            _("Kernel '%s' is not supported."),
-            Kernels,
-            _("Supported kernels : "),
-            Kernels.CURRENT,
-        )
-
-        system_setup.desktop = prompt_bundle(
-            _("Install a desktop environment ? (%s) : "),
-            _("Desktop environment '%s' is not supported."),
-            Desktops,
-            _("Supported desktop environments : "),
-            Desktops.NONE,
-        )
-
-        system_setup.network = prompt_bundle(
-            _("Choose your network stack (%s) : "),
-            _("Network stack '%s' is not supported."),
-            Network,
-            _("Supported network stacks : "),
-            Network.NETWORK_MANAGER,
+        info.ai.system_info.bundles.append(
+            prompt_bundle(
+                _("Choose your network stack (%s) : "),
+                _("Network stack '%s' is not supported."),
+                Network,
+                _("Supported network stacks : "),
+                Network.NETWORK_MANAGER,
+            )
         )
 
         if prompt_bool(_("Install proprietary Nvidia driver ?"), default=False):
-            system_setup.bundles.append(NvidiaDriver(Bundles.NVIDIA))
+            info.ai.system_info.bundles.append(NvidiaDriver(Bundles.NVIDIA))
 
         if prompt_bool(_("Install terminus console font ?"), default=False):
-            system_setup.bundles.append(TerminusFont(Bundles.TERMINUS))
+            info.ai.system_info.bundles.append(TerminusFont(Bundles.TERMINUS))
 
         if prompt_bool(_("Install Cups ?"), default=False):
-            system_setup.bundles.append(Cups(Bundles.CUPS))
+            info.ai.system_info.bundles.append(Cups(Bundles.CUPS))
 
         if prompt_bool(
             _("Install ZSH with GRML configuration ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will install the ZSH shell with GRML "
                 "configuration. GRML is a ZSH pre-configuration used by Archlinux's "
                 "live environment."
             ),
         ):
-            system_setup.bundles.append(GrmlZsh(Bundles.GRML))
+            info.ai.system_info.bundles.append(GrmlZsh(Bundles.GRML))
 
         if prompt_bool(
             _("Install a set of main fonts ?"),
             default=False,
             help_msg=_("If yes, the following packages will be installed :\n%s")
             % " ".join(get_main_fonts()),
         ):
-            system_setup.bundles.append(MainFonts(Bundles.MAIN_FONTS))
+            info.ai.system_info.bundles.append(MainFonts(Bundles.MAIN_FONTS))
 
         if prompt_bool(
             _("Install main file systems support ?"),
             default=False,
             help_msg=_("If yes, the following packages will be installed :\n%s")
             % " ".join(get_main_file_systems()),
         ):
-            system_setup.bundles.append(MainFileSystems(Bundles.MAIN_FILE_SYSTEMS))
+            info.ai.system_info.bundles.append(
+                MainFileSystems(Bundles.MAIN_FILE_SYSTEMS)
+            )
 
         if prompt_bool(
             _("Install and enable ZRAM ?"),
             default=False,
             help_msg=_(
                 "ZRAM is a process to compress datas directly in the RAM instead of moving them in a swap. "
                 "Enabled ZRAM will allow you to compress up to half of your RAM before having to swap. "
                 "This method is more efficient than the swap and do not use your disk but is more CPU demanding. "
                 "ZRAM is fully compatible with a swap, it just has a higher priority."
             ),
         ):
-            system_setup.bundles.append(Zram(Bundles.ZRAM))
+            info.ai.system_info.bundles.append(Zram(Bundles.ZRAM))
 
         if prompt_bool(
             _("Install PipeWire ?"),
             default=False,
             help_msg=_(
                 "If yes, the PipeWire multimedia framework will be installed "
                 "to manage audio and video capture."
             ),
         ):
-            system_setup.bundles.append(PipeWire(Bundles.PIPEWIRE))
+            info.ai.system_info.bundles.append(PipeWire(Bundles.PIPEWIRE))
 
         if prompt_bool(_("Copy ArchCraftsman to the new system ?"), default=False):
-            system_setup.bundles.append(CopyACM(Bundles.COPY_ACM))
+            info.ai.system_info.bundles.append(CopyACM(Bundles.COPY_ACM))
 
-        default_timezone_file = f"/usr/share/zoneinfo/{detected_timezone}"
-        system_setup.timezone = prompt_ln(
+        default_timezone_file = (
+            f"/usr/share/zoneinfo/{info.ai.pre_launch_info.detected_timezone}"
+        )
+        info.ai.system_info.timezone = prompt_ln(
             _("Your timezone (%s) : ") % default_timezone_file,
             default=default_timezone_file,
         )
         user_name_pattern = re.compile("^[a-z][-a-z\\d_]*$")
         user_name_ok = False
         while not user_name_ok:
-            system_setup.user_name = prompt_ln(
+            info.ai.system_info.user_name = prompt_ln(
                 _(
                     "Would you like to add a user? (type username, leave blank if "
                     "none) : "
                 )
             )
-            if system_setup.user_name and not user_name_pattern.match(
-                system_setup.user_name
+            if info.ai.system_info.user_name and not user_name_pattern.match(
+                info.ai.system_info.user_name
             ):
                 print_error(_("Invalid user name."))
                 continue
             user_name_ok = True
-        system_setup.user_full_name = ""
-        if system_setup.user_name:
-            system_setup.user_full_name = prompt_ln(
+        info.ai.system_info.user_full_name = ""
+        if info.ai.system_info.user_name:
+            info.ai.system_info.user_full_name = prompt_ln(
                 _(
                     "What is the %s's full name (type the entire full name, leave blank if none) : "
                 )
-                % system_setup.user_name
+                % info.ai.system_info.user_name
             )
 
-        system_setup.more_pkgs = Packages().ask_packages()
+        info.ai.system_info.more_pkgs = Packages().ask_packages()
 
         print_sub_step(_("%s password configuration : ") % "root")
-        system_setup.root_password = ask_password(
+        info.ai.system_info.root_password = ask_password(
             _("Enter the %s password : ") % "root"
         )
-        if system_setup.user_name:
-            print_sub_step(_("%s password configuration : ") % system_setup.user_name)
-            system_setup.user_password = ask_password(
-                _("Enter the %s password : ") % system_setup.user_name
+        if info.ai.system_info.user_name:
+            print_sub_step(
+                _("%s password configuration : ") % info.ai.system_info.user_name
+            )
+            info.ai.system_info.user_password = ask_password(
+                _("Enter the %s password : ") % info.ai.system_info.user_name
             )
 
-        system_setup.bootloader = Grub(BootLoaders.GRUB)
-        system_setup.micro_codes = Microcodes()
+        info.ai.system_info.bundles.append(Grub(BootLoaders.GRUB))
+        info.ai.system_info.bundles.append(Microcodes(Bundles.MICROCODES))
 
         print_step(_("Summary of choices :"))
-        print_sub_step(_("Your hostname : %s") % system_setup.hostname)
-        system_setup.micro_codes.print_resume()
-        if system_setup.kernel:
-            system_setup.kernel.print_resume()
-        if system_setup.desktop:
-            system_setup.desktop.print_resume()
-        if system_setup.network:
-            system_setup.network.print_resume()
-        for bundle in system_setup.bundles:
+        print_sub_step(_("Your hostname : %s") % info.ai.system_info.hostname)
+        for bundle in info.ai.system_info.bundles:
             if bundle is not None and isinstance(bundle, Bundle):
                 bundle.print_resume()
-        print_sub_step(_("Your timezone : %s") % system_setup.timezone)
-        if system_setup.user_name:
-            print_sub_step(_("Additional user name : %s") % system_setup.user_name)
-            if system_setup.user_full_name:
-                print_sub_step(_("User's full name : %s") % system_setup.user_full_name)
-        if system_setup.more_pkgs:
+        print_sub_step(_("Your timezone : %s") % info.ai.system_info.timezone)
+        if info.ai.system_info.user_name:
+            print_sub_step(
+                _("Additional user name : %s") % info.ai.system_info.user_name
+            )
+            if info.ai.system_info.user_full_name:
+                print_sub_step(
+                    _("User's full name : %s") % info.ai.system_info.user_full_name
+                )
+        if info.ai.system_info.more_pkgs:
             print_sub_step(
-                _("More packages to install : %s") % " ".join(system_setup.more_pkgs)
+                _("More packages to install : %s")
+                % " ".join(info.ai.system_info.more_pkgs)
             )
         user_answer = prompt_bool(_("Is the information correct ?"), default=False)
-    return system_setup
```

## archcraftsman/disk.py

```diff
@@ -14,31 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The disk class module
 """
 import re
-from typing import Optional
 
-from archcraftsman.i18n import I18n
-from archcraftsman.options import PartTypes
+from archcraftsman.base import execute, print_error, prompt
+from archcraftsman.i18n import _
+from archcraftsman.options import FSFormats, PartTypes
 from archcraftsman.partition import Partition
-from archcraftsman.utils import to_iec, prompt, print_error, execute
-
-_ = I18n().gettext
+from archcraftsman.utils import to_iec
 
 
 class Disk:
     """
     A class to represent a disk.
     """
 
     path: str
-    partitions: list
+    partitions: list[Partition]
     total: int
     free_space: int
 
     def __init__(self, path: str):
         """
         Disk initialisation.
         """
@@ -93,35 +91,37 @@
             self.free_space = self.total
 
     def get_efi_partition(self) -> Partition:
         """
         The Disk method to get the EFI partition if it exist. Else return an empty partition object.
         """
         try:
-            return [
-                p for p in self.partitions if PartTypes.EFI in p.part_type_name
-            ].pop()
+            return [p for p in self.partitions if p.part_type == PartTypes.EFI].pop()
         except IndexError:
-            return Partition(None)
+            return Partition(
+                part_type=PartTypes.EFI,
+                part_format_type=FSFormats.VFAT,
+                part_mount_point="/boot/efi",
+            )
 
-    def ask_swapfile_size(self) -> Optional[str]:
+    def ask_swapfile_size(self) -> str:
         """
         The method to ask the user for the swapfile size.
         """
         swapfile_ok = False
         swapfile_size = ""
         swapfile_size_pattern = re.compile("^(\\d*[.,]\\d+|\\d+)([GMk])$")
         default_swapfile_size = to_iec(int(self.total / 32))
         while not swapfile_ok:
             swapfile_size = prompt(
                 _("Swapfile size ? (%s, type '0' for none) : ") % default_swapfile_size,
                 default=default_swapfile_size,
             )
             if swapfile_size == "0":
-                swapfile_size = None
+                swapfile_size = ""
                 swapfile_ok = True
             elif swapfile_size_pattern.match(swapfile_size):
                 swapfile_ok = True
             else:
                 print_error("Invalid swapfile size.")
         return swapfile_size
```

## archcraftsman/i18n.py

```diff
@@ -14,57 +14,34 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The I18n management singleton module
 """
 import gettext
-from threading import Lock
 
+from archcraftsman.options import Languages
 
-class I18nMeta(type):
+_I18N_METHOD = gettext.gettext
+
+
+def update_method(global_language: str):
     """
-    Thread-safe implementation of Singleton to manage translations.
+    Update the translation method to use according to the global language.
     """
 
-    _instances = {}
-    _lock: Lock = Lock()
-
-    def __call__(cls, *args, **kwargs):
-        """
-        Possible changes to the value of the `__init__` argument do not affect
-        the returned instance.
-        """
-        with cls._lock:
-            if cls not in cls._instances:
-                instance = super().__call__(*args, **kwargs)
-                cls._instances[cls] = instance
-        return cls._instances[cls]
+    if global_language != Languages.ENGLISH:
+        translation = gettext.translation(
+            "archcraftsman",
+            localedir="/usr/share/locale",
+            languages=[global_language],
+        )
+        translation.install()
+        global _I18N_METHOD
+        _I18N_METHOD = translation.gettext
 
 
-class I18n(metaclass=I18nMeta):
+def _(message) -> str:
     """
-    The singleton implementation containing the translation method to use.
+    Translate the given text with the translation method.
     """
-
-    def __init__(self) -> None:
-        self.gettext_method = gettext.gettext
-
-    def update_method(self, global_language: str):
-        """
-        Update the translation method to use according to the global language.
-        """
-        if global_language != "EN":
-            translation = gettext.translation(
-                "ArchCraftsman",
-                localedir="/usr/share/locale",
-                languages=[global_language.lower()],
-            )
-            translation.install()
-            self.gettext_method = translation.gettext
-        return self.gettext_method
-
-    def gettext(self, message):
-        """
-        Translate the given text with the translation method.
-        """
-        return self.gettext_method(message)
+    return _I18N_METHOD(message)
```

## archcraftsman/installer.py

```diff
@@ -16,71 +16,63 @@
 
 """
 The ArchCraftsman installer.
 """
 import argparse
 import readline
 import sys
-from importlib.resources import files
 from subprocess import CalledProcessError
 
+from archcraftsman import arguments, config, i18n, info
 from archcraftsman.autopart import auto_partitioning
-from archcraftsman.basesetup import initial_setup, setup_system
-from archcraftsman.globalargs import GlobalArgs
-from archcraftsman.i18n import I18n
-from archcraftsman.manualpart import manual_partitioning
-from archcraftsman.options import FSFormats, PartTypes
-from archcraftsman.packages import Packages
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.shell import shell
-from archcraftsman.utils import (
-    elevate,
+from archcraftsman.base import (
     execute,
     glob_completer,
     print_error,
     print_step,
     print_sub_step,
-    prompt_bool,
 )
-
-_ = I18n().gettext
+from archcraftsman.basesetup import pre_launch, setup_system
+from archcraftsman.i18n import _
+from archcraftsman.manualpart import manual_partitioning
+from archcraftsman.options import Desktops, FSFormats, Languages, PartTypes
+from archcraftsman.shell import shell
+from archcraftsman.utils import prompt_bool
 
 
-def install(pre_launch_info: PreLaunchInfo):
+def install():
     """
     The main installation method.
     """
-    partitioning_info: PartitioningInfo = PartitioningInfo()
     try:
-        system_info = setup_system(pre_launch_info.detected_timezone)
+        if not arguments.config():
+            setup_system()
 
-        partitioning_info_ok = None
+        partitioning_info_ok: bool = bool(arguments.config())
         while not partitioning_info_ok:
             print_step(_("Partitioning :"))
             want_auto_part = prompt_bool(
                 _("Do you want an automatic partitioning ?"), default=False
             )
             if want_auto_part:
-                partitioning_info_ok, partitioning_info = auto_partitioning()
+                partitioning_info_ok = auto_partitioning()
             else:
-                partitioning_info_ok, partitioning_info = manual_partitioning()
+                partitioning_info_ok = manual_partitioning()
 
-        partitioning_info.format_and_mount_partitions()
+        info.ai.partitioning_info.format_and_mount_partitions()
 
         print_step(_("Updating mirrors..."), clear=False)
         execute(
             "reflector --verbose -phttps -f10 -l10 --sort rate -a2 --save /etc/pacman.d/mirrorlist"
         )
 
         base_pkgs = set()
         base_pkgs.update(["base", "base-devel", "linux-firmware"])
 
-        if system_info.kernel:
-            base_pkgs.update(system_info.kernel.packages(system_info))
+        base_pkgs.update(info.ai.system_info.kernel().packages())
 
         pkgs = set()
         pkgs.update(
             [
                 "man-db",
                 "man-pages",
                 "texinfo",
@@ -95,223 +87,169 @@
                 "numlockx",
                 "net-tools",
                 "polkit",
                 "pacman-contrib",
             ]
         )
 
-        if pre_launch_info.global_language.lower() != "en" and execute(
-            f"pacman -Si man-pages-{pre_launch_info.global_language.lower()} &>/dev/null",
+        if info.ai.pre_launch_info.global_language.lower() != "en" and execute(
+            f"pacman -Si man-pages-{info.ai.pre_launch_info.global_language.lower()} &>/dev/null",
             check=False,
         ):
-            pkgs.add(f"man-pages-{pre_launch_info.global_language.lower()}")
+            pkgs.add(f"man-pages-{info.ai.pre_launch_info.global_language.lower()}")
 
-        if partitioning_info.btrfs_in_use:
+        if info.ai.partitioning_info.btrfs_in_use:
             pkgs.add("btrfs-progs")
 
-        pkgs.update(system_info.micro_codes.packages(system_info))
-
-        if system_info.bootloader:
-            pkgs.update(system_info.bootloader.packages(system_info))
+        for bundle in info.ai.system_info.bundles:
+            pkgs.update(bundle.packages())
 
-        if system_info.desktop:
-            pkgs.update(system_info.desktop.packages(system_info))
-
-        if system_info.network:
-            pkgs.update(system_info.network.packages(system_info))
-
-        for bundle in system_info.bundles:
-            pkgs.update(bundle.packages(system_info))
-
-        if len(system_info.more_pkgs) > 0:
-            pkgs.update(system_info.more_pkgs)
+        if len(info.ai.system_info.more_pkgs) > 0:
+            pkgs.update(info.ai.system_info.more_pkgs)
 
         print_step(_("Installation of the base..."), clear=False)
         execute(f'pacstrap -K /mnt {" ".join(base_pkgs)}')
 
         print_step(_("System configuration..."), clear=False)
         execute('sed -i "s|#en_US.UTF-8 UTF-8|en_US.UTF-8 UTF-8|g" /mnt/etc/locale.gen')
         execute('sed -i "s|#en_US ISO-8859-1|en_US ISO-8859-1|g" /mnt/etc/locale.gen')
-        if pre_launch_info.global_language == "FR":
+        if info.ai.pre_launch_info.global_language == Languages.FRENCH:
             execute(
                 'sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /mnt/etc/locale.gen'
             )
             execute(
                 'sed -i "s|#fr_FR ISO-8859-1|fr_FR ISO-8859-1|g" /mnt/etc/locale.gen'
             )
             execute('echo "LANG=fr_FR.UTF-8" >/mnt/etc/locale.conf')
         else:
             execute('echo "LANG=en_US.UTF-8" >/mnt/etc/locale.conf')
-        execute(f'echo "KEYMAP={pre_launch_info.keymap}" >/mnt/etc/vconsole.conf')
-        execute(f'echo "{system_info.hostname}" >/mnt/etc/hostname')
+        execute(
+            f'echo "KEYMAP={info.ai.pre_launch_info.keymap}" >/mnt/etc/vconsole.conf'
+        )
+        execute(f'echo "{info.ai.system_info.hostname}" >/mnt/etc/hostname')
         execute(
             f"""
             {{
                 echo "127.0.0.1 localhost"
                 echo "::1 localhost"
-                echo "127.0.1.1 {system_info.hostname}.localdomain {system_info.hostname}"
+                echo "127.0.1.1 {info.ai.system_info.hostname}.localdomain {info.ai.system_info.hostname}"
             }} >>/mnt/etc/hosts
         """
         )
         execute("cp /etc/pacman.d/mirrorlist /mnt/etc/pacman.d/mirrorlist")
 
         print_step(_("Locales configuration..."), clear=False)
         execute(
-            f'arch-chroot /mnt bash -c "ln -sf {system_info.timezone} /etc/localtime"'
+            f'arch-chroot /mnt bash -c "ln -sf {info.ai.system_info.timezone} /etc/localtime"'
         )
         execute('arch-chroot /mnt bash -c "locale-gen"')
 
         print_step(_("Installation of the remaining packages..."), clear=False)
         execute('sed -i "s|#Color|Color|g" /mnt/etc/pacman.conf')
         execute(
             'sed -i "s|#ParallelDownloads = 5|ParallelDownloads = 5\\nDisableDownloadTimeout|g" /mnt/etc/pacman.conf'
         )
         execute('arch-chroot /mnt bash -c "pacman --noconfirm -Sy archlinux-keyring"')
         execute('arch-chroot /mnt bash -c "pacman --noconfirm -Su"')
         execute(f'arch-chroot /mnt bash -c "pacman --noconfirm -S {" ".join(pkgs)}"')
 
         if (
             PartTypes.SWAP
-            not in [part.part_type for part in partitioning_info.partitions]
-            and partitioning_info.swapfile_size is not None
+            not in [part.part_type for part in info.ai.partitioning_info.partitions]
+            and info.ai.partitioning_info.swapfile_size
         ):
             print_step(_("Creation and activation of the swapfile..."), clear=False)
-            if partitioning_info.root_partition.part_format_type == FSFormats.BTRFS:
+            if (
+                info.ai.partitioning_info.root_partition().part_format_type
+                == FSFormats.BTRFS
+            ):
                 execute(
                     "btrfs subvolume create /mnt/swap && "
                     "cd /mnt/swap && "
                     "truncate -s 0 ./swapfile && "
                     "chattr +C ./swapfile && "
                     "btrfs property set ./swapfile compression none && "
                     "cd -"
                 )
             else:
                 execute("mkdir -p /mnt/swap")
             execute(
-                f'fallocate -l "{partitioning_info.swapfile_size}" /mnt/swap/swapfile'
+                f'fallocate -l "{info.ai.partitioning_info.swapfile_size}" /mnt/swap/swapfile'
             )
             execute("chmod 600 /mnt/swap/swapfile")
             execute("mkswap /mnt/swap/swapfile")
             execute("swapon /mnt/swap/swapfile")
 
         print_step(_("Generating fstab..."), clear=False)
         execute("genfstab -U /mnt >>/mnt/etc/fstab")
 
-        if system_info.desktop:
+        if info.ai.system_info.desktop().name != Desktops.NONE:
             print_step(_("Desktop configuration..."), clear=False)
-            system_info.desktop.configure(
-                system_info, pre_launch_info, partitioning_info
-            )
+            info.ai.system_info.desktop().configure()
 
-        if system_info.network:
-            print_step(_("Network configuration..."), clear=False)
-            system_info.network.configure(
-                system_info, pre_launch_info, partitioning_info
-            )
+        print_step(_("Network configuration..."), clear=False)
+        info.ai.system_info.network().configure()
 
         execute('arch-chroot /mnt bash -c "systemctl enable systemd-timesyncd"')
 
-        if system_info.bootloader:
-            print_step(_("Installation and configuration of the grub..."), clear=False)
-            system_info.bootloader.configure(
-                system_info, pre_launch_info, partitioning_info
-            )
+        print_step(_("Installation and configuration of the grub..."), clear=False)
+        info.ai.system_info.bootloader().configure()
 
         print_step(_("Users configuration..."), clear=False)
         print_sub_step(_("Root account configuration..."))
-        if system_info.root_password:
+        if info.ai.system_info.root_password:
             execute(
-                f"arch-chroot /mnt bash -c \"echo 'root:{system_info.root_password}' | chpasswd\""
+                f"arch-chroot /mnt bash -c \"echo 'root:{info.ai.system_info.root_password}' | chpasswd\""
+            )
+        if info.ai.system_info.user_name:
+            print_sub_step(
+                _("%s account configuration...") % info.ai.system_info.user_name
             )
-        if system_info.user_name:
-            print_sub_step(_("%s account configuration...") % system_info.user_name)
             execute(
                 'sed -i "s|# %wheel ALL=(ALL:ALL) ALL|%wheel ALL=(ALL:ALL) ALL|g" /mnt/etc/sudoers'
             )
             execute(
                 f'arch-chroot /mnt bash -c "useradd --shell=/bin/bash --groups=wheel '
-                f'--create-home {system_info.user_name}"'
+                f'--create-home {info.ai.system_info.user_name}"'
             )
-            if system_info.user_full_name:
+            if info.ai.system_info.user_full_name:
                 execute(
                     f"arch-chroot /mnt bash -c "
-                    f"\"chfn -f '{system_info.user_full_name}' {system_info.user_name}\""
+                    f"\"chfn -f '{info.ai.system_info.user_full_name}' {info.ai.system_info.user_name}\""
                 )
-            if system_info.user_password:
+            if info.ai.system_info.user_password:
                 execute(
-                    f"arch-chroot /mnt bash -c \"echo '{system_info.user_name}:"
-                    f"{system_info.user_password}' | chpasswd\""
+                    f"arch-chroot /mnt bash -c \"echo '{info.ai.system_info.user_name}:"
+                    f"{info.ai.system_info.user_password}' | chpasswd\""
                 )
 
         print_step(_("Extra packages configuration if needed..."), clear=False)
-        for bundle in system_info.bundles:
-            bundle.configure(system_info, pre_launch_info, partitioning_info)
+        for bundle in info.ai.system_info.others():
+            bundle.configure()
 
-        partitioning_info.umount_partitions()
+        config.serialize()
+        info.ai.partitioning_info.umount_partitions()
 
         print_step(
             _("Installation complete ! You can reboot your system."), clear=False
         )
 
     except KeyboardInterrupt:
         print_error(_("Script execution interrupted by the user !"), do_pause=False)
-        partitioning_info.umount_partitions()
-        sys.exit(1)
-    except CalledProcessError as exception:
-        print_error(
-            _("A subprocess execution failed ! See the following error: %s")
-            % exception,
-            do_pause=False,
-        )
-        partitioning_info.umount_partitions()
-        sys.exit(1)
-    except EOFError:
-        sys.exit(1)
-
-
-def pre_launch_steps() -> PreLaunchInfo:
-    """
-    The method to proceed to the pre-launch steps
-    """
-    print_step(_("Running pre-launch steps : "), clear=False)
-    locale_file_path = files("archcraftsman.locales").joinpath("fr.po")
-    execute(
-        f"msgfmt -o /usr/share/locale/fr/LC_MESSAGES/ArchCraftsman.mo {locale_file_path} &>/dev/null",
-        force=True,
-        sudo=True,
-    )
-    if GlobalArgs().install():
-        execute('sed -i "s|#Color|Color|g" /etc/pacman.conf')
-        execute(
-            'sed -i "s|#ParallelDownloads = 5|ParallelDownloads = 5\\nDisableDownloadTimeout|g" /etc/pacman.conf'
-        )
-
-    if GlobalArgs().install():
-        print_sub_step(_("Synchronising repositories..."))
-        execute("pacman -Sy &>/dev/null")
-        Packages()
-
-    return initial_setup()
-
-
-def pre_launch() -> PreLaunchInfo:
-    """
-    A pre-launch steps method.
-    """
-    try:
-        return pre_launch_steps()
-    except KeyboardInterrupt:
-        print_error(_("Script execution interrupted by the user !"), do_pause=False)
+        config.serialize()
+        info.ai.partitioning_info.umount_partitions()
         sys.exit(1)
     except CalledProcessError as exception:
         print_error(
             _("A subprocess execution failed ! See the following error: %s")
             % exception,
             do_pause=False,
         )
+        config.serialize()
+        info.ai.partitioning_info.umount_partitions()
         sys.exit(1)
     except EOFError:
         sys.exit(1)
 
 
 def main():
     """
@@ -331,42 +269,45 @@
         "--shell",
         action="store_const",
         const=True,
         default=False,
         help="Start ArchCraftsman in interactive shell mode. Useless if used with --install.",
     )
     parser.add_argument(
+        "-c",
+        "--config",
+        action="store",
+        help="Used to specify a config file to use. Can be used with both --install and --shell.",
+    )
+    parser.add_argument(
         "-t",
         "--test",
         action="store_const",
         const=True,
         default=False,
         help="Used to test the installer. No destructive commands will be executed.",
     )
-    GlobalArgs(parser.parse_args())
+    arguments.init(parser.parse_args())
 
     readline.set_completer_delims(" \t\n;")
     readline.parse_and_bind("tab: complete")
     readline.set_completer(glob_completer)
 
-    if not GlobalArgs().is_call_ok():
+    if not arguments.is_call_ok():
         parser.print_help()
         sys.exit(1)
 
-    if GlobalArgs().install():
-        if not elevate():
-            print_error(_("This script must be run as root."), do_pause=False)
-            sys.exit(1)
-        pre_launch_info = pre_launch()
-        I18n().update_method(pre_launch_info.global_language)
-        install(pre_launch_info)
+    if arguments.install():
+        pre_launch()
+        i18n.update_method(info.ai.pre_launch_info.global_language)
+        install()
         sys.exit(0)
 
-    if GlobalArgs().shell():
-        pre_launch_info = initial_setup(shell_mode=True)
-        I18n().update_method(pre_launch_info.global_language)
+    if arguments.shell():
+        pre_launch(shell_mode=True)
+        i18n.update_method(info.ai.pre_launch_info.global_language)
         shell()
         sys.exit(0)
 
 
 if __name__ == "__main__":
     main()
```

## archcraftsman/manualpart.py

```diff
@@ -13,58 +13,48 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The manual partitioning system module
 """
-from archcraftsman.disk import Disk
-from archcraftsman.i18n import I18n
-from archcraftsman.options import PartTypes
-from archcraftsman.partition import Partition
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.utils import (
-    ask_drive,
+from archcraftsman import info
+from archcraftsman.base import (
     execute,
     is_bios,
     log,
     print_error,
     print_step,
     print_sub_step,
     prompt,
-    prompt_bool,
-    prompt_option,
 )
-
-_ = I18n().gettext
+from archcraftsman.disk import Disk
+from archcraftsman.i18n import _
+from archcraftsman.options import PartTypes
+from archcraftsman.partition import Partition
+from archcraftsman.utils import ask_drive, prompt_bool, prompt_option
 
 
-def manual_partitioning() -> tuple[bool, PartitioningInfo]:
+def manual_partitioning(change_disks: bool = True) -> bool:
     """
     The method to proceed to the manual partitioning.
     """
-    partitioning_info = PartitioningInfo()
     user_answer = False
     partitioned_disks = []
     while not user_answer:
         print_step(_("Manual partitioning :"))
         print_sub_step(
             _("Partitioned drives so far : %s") % " ".join(partitioned_disks)
         )
         execute("fdisk -l", force=True, sudo=True)
-        target_disk = ask_drive(
-            _(
-                "On which drive should Archlinux be installed ? (type the entire name, for example '/dev/sda') : "
-            ),
-            _("The target drive '%s' doesn't exist."),
-            _("Detected drives :"),
-        )
+        target_disk = ask_drive()
         if target_disk not in partitioned_disks:
             partitioned_disks.append(target_disk)
-        execute(f'cfdisk "{target_disk}"')
+        if change_disks:
+            execute(f'cfdisk "{target_disk}"')
         print_step(_("Manual partitioning :"))
         print_sub_step(
             _("Partitioned drives so far : %s") % " ".join(partitioned_disks)
         )
         execute("fdisk -l", force=True, sudo=True)
         other_drive = prompt_bool(
             _("Do you want to partition an other drive ?"), default=False
@@ -74,22 +64,26 @@
         for disk_path in partitioned_disks:
             log(f"Detected disk: {disk_path}")
             disk = Disk(disk_path)
             partitions = [partition.path for partition in disk.partitions]
             log(f"Partitions: {partitions}")
             for partition in partitions:
                 log(f"Partition : {partition}")
-                partitioning_info.partitions.append(Partition(path=partition))
+                info.ai.partitioning_info.partitions.append(Partition(path=partition))
         print_step(
             _("Detected target drive partitions : %s")
             % " ".join(
-                [part.path for part in partitioning_info.partitions if part.path]
+                [
+                    part.path
+                    for part in info.ai.partitioning_info.partitions
+                    if part.path
+                ]
             )
         )
-        for partition in partitioning_info.partitions:
+        for partition in info.ai.partitioning_info.partitions:
             print_step(_("Partition :"), clear=False)
             print_sub_step(str(partition))
             if is_bios():
                 partition_type = prompt_option(
                     _("What is the role of this partition ? (%s) : "),
                     _("Partition type '%s' is not supported."),
                     PartTypes,
@@ -107,16 +101,15 @@
                 )
             if not is_bios() and partition_type == PartTypes.EFI:
                 partition.part_type = PartTypes.EFI
                 partition.part_mount_point = "/boot/efi"
             elif partition_type == PartTypes.ROOT:
                 partition.part_type = PartTypes.ROOT
                 partition.part_mount_point = "/"
-                partitioning_info.root_partition = partition
-                partitioning_info.main_disk = f"/dev/{partition.disk_name}"
+                info.ai.partitioning_info.main_disk = f"/dev/{partition.disk_name()}"
             elif partition_type == PartTypes.BOOT:
                 partition.part_type = PartTypes.BOOT
                 partition.part_mount_point = "/boot"
             elif partition_type == PartTypes.HOME:
                 partition.part_type = PartTypes.HOME
                 partition.part_mount_point = "/home"
             elif partition_type == PartTypes.SWAP:
@@ -128,56 +121,58 @@
                 partition.part_mount_point = prompt(
                     _("What is the mounting point of this partition ? : ")
                 )
             partition.ask_for_format()
             partition.ask_for_encryption()
 
         if not is_bios() and PartTypes.EFI not in [
-            part.part_type for part in partitioning_info.partitions
+            part.part_type for part in info.ai.partitioning_info.partitions
         ]:
             print_error(_("The EFI partition is required for system installation."))
-            partitioning_info.partitions.clear()
+            info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
         if PartTypes.ROOT not in [
-            part.part_type for part in partitioning_info.partitions
+            part.part_type for part in info.ai.partitioning_info.partitions
         ]:
             print_error(_("The Root partition is required for system installation."))
-            partitioning_info.partitions.clear()
+            info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
         if True in [
             part.encrypted and part.part_type == PartTypes.ROOT
-            for part in partitioning_info.partitions
+            for part in info.ai.partitioning_info.partitions
         ] and PartTypes.BOOT not in [
-            part.part_type for part in partitioning_info.partitions
+            part.part_type for part in info.ai.partitioning_info.partitions
         ]:
             print_error(_("The Boot partition is required for system installation."))
-            partitioning_info.partitions.clear()
+            info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
             continue
         if PartTypes.SWAP not in [
-            part.part_type for part in partitioning_info.partitions
+            part.part_type for part in info.ai.partitioning_info.partitions
         ]:
-            partitioning_info.swapfile_size = Disk(
-                partitioning_info.main_disk
+            info.ai.partitioning_info.swapfile_size = Disk(
+                info.ai.partitioning_info.main_disk
             ).ask_swapfile_size()
 
         print_step(_("Summary of choices :"))
-        for partition in partitioning_info.partitions:
+        for partition in info.ai.partitioning_info.partitions:
             print_sub_step(partition.summary())
         if (
             PartTypes.SWAP
-            not in [part.part_type for part in partitioning_info.partitions]
-            and partitioning_info.swapfile_size
+            not in [part.part_type for part in info.ai.partitioning_info.partitions]
+            and info.ai.partitioning_info.swapfile_size
         ):
-            print_sub_step(_("Swapfile size : %s") % partitioning_info.swapfile_size)
+            print_sub_step(
+                _("Swapfile size : %s") % info.ai.partitioning_info.swapfile_size
+            )
         user_answer = prompt_bool(_("Is the information correct ?"), default=False)
         if not user_answer:
             want_to_change = prompt_bool(
                 _("Do you want to change the partitioning mode ?"), default=False
             )
             if want_to_change:
-                return False, partitioning_info
-            partitioning_info.partitions.clear()
+                return False
+            info.ai.partitioning_info.partitions.clear()
             partitioned_disks.clear()
-    return True, partitioning_info
+    return True
```

## archcraftsman/options.py

```diff
@@ -15,32 +15,37 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The all available options module.
 """
 from enum import Enum, auto
 
-from archcraftsman.i18n import I18n
-
-_ = I18n().gettext
-
 
 class OptionEnum(str, Enum):
     """
     The Enum base method for options.
     """
 
     @staticmethod
     def _generate_next_value_(
         name: str, start: int, count: int, last_values: list
     ) -> str:
         return name.lower().replace("_", "")
 
-    def __str__(self):
-        return self.name.lower().replace("_", " ").capitalize()
+    def __str__(self) -> str:
+        return self.value
+
+
+class Languages(OptionEnum):
+    """
+    All available languages.
+    """
+
+    ENGLISH = auto()
+    FRENCH = auto()
 
 
 class Commands(OptionEnum):
     """
     All available commands.
     """
 
@@ -55,14 +60,15 @@
 class SubCommands(OptionEnum):
     """
     All available sub-commands.
     """
 
     INSTALL = auto()
     UNINSTALL = auto()
+    CANCEL = auto()
 
 
 class Kernels(OptionEnum):
     """
     All kernel options.
     """
 
@@ -124,14 +130,23 @@
     NVIDIA = auto()
     PIPEWIRE = auto()
     TERMINUS = auto()
     ZRAM = auto()
     COPY_ACM = auto()
 
 
+class ShellBundles(OptionEnum):
+    """
+    All shell options.
+    """
+
+    YAY = auto()
+    GENERATE_CONFIG = auto()
+
+
 class FSFormats(OptionEnum):
     """
     All file system format options.
     """
 
     VFAT = auto()
     EXT4 = auto()
@@ -156,7 +171,37 @@
     EFI = auto()
     ROOT = auto()
     BOOT = auto()
     HOME = auto()
     SWAP = auto()
     NOT_USED = auto()
     OTHER = auto()
+
+
+class BundleTypes(OptionEnum):
+    """
+    All bundle type options.
+    """
+
+    BOOTLOADER = auto()
+    DESKTOP = auto()
+    KERNEL = auto()
+    MICRO_CODES = auto()
+    NETWORK = auto()
+    OTHER = auto()
+
+
+def get_btype_by_name(name: str) -> BundleTypes:
+    """
+    Get the bundle type by name.
+    """
+    if name == Bundles.MICROCODES.value:
+        return BundleTypes.MICRO_CODES
+    if name in [option.value for option in BootLoaders]:
+        return BundleTypes.BOOTLOADER
+    if name in [option.value for option in Desktops]:
+        return BundleTypes.DESKTOP
+    if name in [option.value for option in Kernels]:
+        return BundleTypes.KERNEL
+    if name in [option.value for option in Network]:
+        return BundleTypes.NETWORK
+    return BundleTypes.OTHER
```

## archcraftsman/packages.py

```diff
@@ -15,20 +15,18 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The packages management singleton module
 """
 import readline
 from threading import Lock
-from archcraftsman.globalargs import GlobalArgs
 
-from archcraftsman.i18n import I18n
-from archcraftsman.utils import prompt_ln, print_error, execute, glob_completer
-
-_ = I18n().gettext
+from archcraftsman import arguments
+from archcraftsman.base import execute, glob_completer, print_error, prompt_ln
+from archcraftsman.i18n import _
 
 
 class PackagesMeta(type):
     """
     Thread-safe implementation of Singleton to store all archlinux packages.
     """
 
@@ -48,61 +46,61 @@
 
 
 class Packages(metaclass=PackagesMeta):
     """
     The singleton implementation containing all archlinux packages and autocompleted prompt method.
     """
 
-    packages: set[str]
+    packages: list[str]
 
     def __init__(self) -> None:
-        self.packages = set(
+        self.packages = (
             execute(
                 "pacman -Sl | awk '{print $2}'",
                 check=False,
                 capture_output=True,
             )
             .output.strip()
             .split("\n")
         )
 
     def exist(self, package: str) -> bool:
         """
         A method to check if a package exist.
         """
-        return GlobalArgs().test() or package in self.packages
+        return arguments.test() or package in self.packages
 
-    def ask_packages(self) -> set[str]:
+    def ask_packages(self) -> list[str]:
         """
         A method to ask the user for more packages to install.
         """
         readline.set_completer(
             lambda text, state: (
                 [
                     package
                     for package in self.packages
                     if (text and package.startswith(text))
                 ]
             )[state]
         )
 
         pkgs_select_ok = False
-        more_pkgs = set()
+        more_pkgs = []
         while not pkgs_select_ok:
-            more_pkgs = set()
+            more_pkgs = []
             more_pkgs_str = prompt_ln(
                 _(
                     "Install more packages ? (type extra packages full names, example : 'htop neofetch', "
                     "leave blank if none) : "
                 )
             )
             pkgs_select_ok = True
             if more_pkgs_str:
                 for pkg in more_pkgs_str.split():
                     if not self.exist(pkg):
                         pkgs_select_ok = False
                         print_error(_("Package %s doesn't exist.") % pkg)
                         break
-                    more_pkgs.add(pkg)
+                    more_pkgs.append(pkg)
 
         readline.set_completer(glob_completer)
         return more_pkgs
```

## archcraftsman/partition.py

```diff
@@ -18,109 +18,104 @@
 The partition class module
 """
 import json
 import os
 from subprocess import CalledProcessError
 from typing import Optional
 
-from archcraftsman.i18n import I18n
-from archcraftsman.options import PartTypes, FSFormats
+from archcraftsman.base import execute, print_sub_step
+from archcraftsman.i18n import _
+from archcraftsman.options import FSFormats, PartTypes
 from archcraftsman.utils import (
-    execute,
-    prompt_bool,
-    to_iec,
-    ask_format_type,
     ask_encryption_block_name,
+    ask_format_type,
     from_iec,
-    print_sub_step,
+    prompt_bool,
+    to_iec,
 )
 
-_ = I18n().gettext
-
 
 class Partition:
     """
     A class to represent a partition.
     """
 
-    index: Optional[int]
-    path: Optional[str]
-    size: int
-    part_type_name: str
-    disk_name: str
-    fs_type: str
-    uuid: str
-    part_type: Optional[PartTypes]
-    part_mount_point: Optional[str]
-    part_format_type: Optional[FSFormats]
-    part_format: bool
-
-    part_mounted: bool = False
-    encrypted: bool = False
-    block_name: Optional[str] = None
-
     def __init__(
         self,
-        index: Optional[int] = None,
-        path: Optional[str] = None,
-        part_type: Optional[PartTypes] = None,
-        part_mount_point: Optional[str] = None,
-        part_format_type: Optional[FSFormats] = None,
+        index: int = 0,
+        path: str = "",
+        part_type: PartTypes = PartTypes.OTHER,
+        part_mount_point: str = "",
+        part_format_type: FSFormats = FSFormats.EXT4,
         part_format: bool = True,
-        compute: bool = True,
+        encrypted: bool = False,
+        block_name: str = "",
     ):
         """
         Partition initialisation.
         """
         self.index = index
         self.part_type = part_type
         self.part_mount_point = part_mount_point
         self.part_format_type = part_format_type
         self.part_format = part_format
-        if path is None:
-            self.path = ""
-            self.size = 0
-            self.part_type_name = ""
-            self.fs_type = ""
-            self.uuid = ""
-        else:
-            self.path = path
-            if compute:
-                self.compute()
+        self.encrypted = encrypted
+        self.block_name = block_name
+        self.path = path
 
     def __str__(self) -> str:
         """
         Partition str formatting.
         """
         formatted_str = (
-            f"'{self.path}' - '{self.part_type_name}' - '{to_iec(int(self.size))}'"
+            f"'{self.path}' - '{self.part_type_name()}' - '{to_iec(int(self.size()))}'"
         )
         return formatted_str
 
-    def compute(self):
+    def size(self) -> int:
         """
-        A method to compute partition information.
+        A method to get the partition size.
         """
-        self.size = from_iec(
+        return from_iec(
             execute(
                 f'lsblk -nld "{self.path}" -o SIZE', force=True, capture_output=True
             ).output.strip()
         )
-        self.part_type_name = execute(
+
+    def part_type_name(self) -> str:
+        """
+        A method to get the partition type name.
+        """
+        return execute(
             f'lsblk -nld "{self.path}" -o PARTTYPENAME',
             force=True,
             capture_output=True,
         ).output.strip()
-        self.disk_name = execute(
+
+    def disk_name(self) -> str:
+        """
+        A method to get the disk name.
+        """
+        return execute(
             f'lsblk -nld "{self.path}" -o PKNAME', force=True, capture_output=True
         ).output.strip()
-        self.fs_type = execute(
+
+    def fs_type(self) -> str:
+        """
+        A method to get the filesystem type.
+        """
+        return execute(
             f'lsblk -nld "{self.path}" -o FSTYPE', force=True, capture_output=True
         ).output.strip()
-        self.uuid = execute(
+
+    def uuid(self) -> str:
+        """
+        A method to get the partition uuid.
+        """
+        return execute(
             f'lsblk -nld "{self.path}" -o UUID', force=True, capture_output=True
         ).output.strip()
 
     def need_format(self):
         """
         Method to know if the partition need to be formatted
         """
@@ -190,17 +185,15 @@
         """
         A method to get the partition summary.
         """
         if self.part_format:
             formatting = _("yes")
         else:
             formatting = _("no")
-        name = "NO_NAME"
-        if self.index is not None:
-            name = str(self.index + 1)
+        name = str(self.index + 1)
         if self.path:
             name = self.path
         if self.part_type == PartTypes.SWAP:
             return _("%s : %s") % (self.part_type, name)
         summary = _("%s : %s (mounting point : %s, format %s, format type %s)") % (
             self.part_type,
             name,
@@ -240,86 +233,94 @@
             case FSFormats.BTRFS:
                 if self.part_format:
                     execute(f'mkfs.btrfs -f "{self.real_path()}"')
             case _:
                 if self.part_format:
                     execute(f'mkfs.ext4 "{self.real_path()}"')
 
+    def is_mounted(self) -> bool:
+        """
+        A method to detect if the partition is mounted.
+        """
+        return bool(
+            execute(
+                f"cat /proc/mounts | grep {self.real_path()}",
+                check=False,
+                capture_output=True,
+                force=True,
+            )
+        )
+
     def mount(self):
         """
         A method to mount the partition.
         """
         print_sub_step(_("Mounting %s...") % (self.real_path()))
         match self.part_format_type:
             case FSFormats.BTRFS:
                 execute(
                     f'mount --mkdir -o compress=zstd "{self.real_path()}" "/mnt{self.part_mount_point}"'
                 )
             case _:
                 execute(
                     f'mount --mkdir "{self.real_path()}" "/mnt{self.part_mount_point}"'
                 )
-        self.part_mounted = True
 
     def umount(self) -> bool:
         """
         A method to unmount the partition.
         """
         try:
             print_sub_step(_("Unmounting %s...") % (self.real_path()))
             execute(f'umount "/mnt{self.part_mount_point}"')
             if self.encrypted:
                 print_sub_step(_("Closing %s...") % (self.real_path()))
                 execute(f"cryptsetup close {self.block_name}")
-            self.part_mounted = False
         except CalledProcessError:
             return False
         return True
 
     def build_partition_name(self, disk_name: str):
         """
         A method to build a partition name with a disk and an index.
         """
         block_devices_str = execute("lsblk -J", force=True, capture_output=True).output
         if not block_devices_str:
             return
         block_devices_json = json.loads(block_devices_str)
         if (
-            block_devices_json is None
+            not block_devices_json
             or not isinstance(block_devices_json, dict)
             or "blockdevices" not in dict(block_devices_json)
         ):
             return
         block_devices = dict(block_devices_json).get("blockdevices")
-        if block_devices is None or not isinstance(block_devices, list):
+        if not block_devices or not isinstance(block_devices, list):
             return
         disk = next(
             (
                 d
                 for d in block_devices
-                if d is not None
+                if d
                 and isinstance(d, dict)
                 and "name" in d
                 and dict(d).get("name") == os.path.basename(disk_name)
             ),
             None,
         )
-        if disk is None or not isinstance(disk, dict) or "children" not in dict(disk):
+        if not disk or not isinstance(disk, dict) or "children" not in dict(disk):
             return
         partitions = dict(disk).get("children")
         if (
-            partitions is None
+            not partitions
             or not isinstance(partitions, list)
-            or self.index
-            and len(list(partitions)) <= self.index
+            or len(list(partitions)) <= self.index
         ):
             return
-        partition = None
-        if self.index is not None:
-            partition = list(partitions)[self.index]
+        partition = list(partitions)[self.index]
         if (
-            partition is None
+            not partition
             or not isinstance(partition, dict)
             or "name" not in dict(partition)
         ):
             return
         self.path = f'/dev/{dict(partition).get("name")}'
```

## archcraftsman/partitioninginfo.py

```diff
@@ -14,70 +14,89 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The module of PartitioningInfo class.
 """
 import re
-from typing import Optional
+import subprocess
 
-from archcraftsman.i18n import I18n
-from archcraftsman.options import FSFormats
+from archcraftsman import arguments
+from archcraftsman.base import execute, print_error, print_step
+from archcraftsman.i18n import _
+from archcraftsman.options import FSFormats, PartTypes
 from archcraftsman.partition import Partition
-from archcraftsman.utils import print_step, execute
-
-_ = I18n().gettext
 
 
 class PartitioningInfo:
     """
     The class to contain all partitioning information.
     """
 
-    partitions: list[Partition]
-    root_partition: Partition
-    swapfile_size: Optional[str]
-    main_disk: str
-
-    btrfs_in_use: bool = False
+    def __init__(
+        self,
+        swapfile_size: str = "",
+        main_disk: str = "",
+        btrfs_in_use: bool = False,
+    ) -> None:
+        self.partitions: list[Partition] = []
+        self.swapfile_size = swapfile_size
+        self.main_disk = main_disk
+        self.btrfs_in_use = btrfs_in_use
 
-    def __init__(self) -> None:
-        self.partitions = []
+    def root_partition(self) -> Partition:
+        """
+        The root partition retrieving method.
+        """
+        return next(
+            partition
+            for partition in self.partitions
+            if partition.part_type == PartTypes.ROOT
+        )
 
     def format_and_mount_partitions(self):
         """
         A method to format and mount all partitions.
         """
         print_step(_("Formatting and mounting partitions..."), clear=False)
 
-        for partition in self.partitions:
-            if partition.part_format_type == FSFormats.BTRFS:
-                self.btrfs_in_use = True
-            partition.format_partition()
+        formatting_ok = False
+        while not formatting_ok:
+            try:
+                for partition in self.partitions:
+                    if partition.part_format_type == FSFormats.BTRFS:
+                        self.btrfs_in_use = True
+                    partition.format_partition()
+                formatting_ok = True
+            except subprocess.CalledProcessError as exception:
+                self.umount_partitions()
+                print_error(
+                    _("A subprocess execution failed ! See the following error: %s")
+                    % exception
+                )
 
         not_mounted_partitions = [
             partition
             for partition in self.partitions
-            if not partition.part_mounted and partition.part_mount_point
+            if not partition.is_mounted() and partition.part_mount_point
         ]
         not_mounted_partitions.sort(
             key=lambda part: 0
             if not part.part_mount_point
             else len(part.part_mount_point)
         )
 
-        while False in [partition.part_mounted for partition in not_mounted_partitions]:
+        while not arguments.test() and False in [
+            partition.is_mounted() for partition in not_mounted_partitions
+        ]:
             for partition in not_mounted_partitions:
                 if partition.part_format_type == FSFormats.BTRFS:
                     self.btrfs_in_use = True
                 partition.mount()
 
-        for partition in self.partitions:
-            partition.compute()
-
     def umount_partitions(self):
         """
         A method to unmount all mounted partitions.
         """
         print_step(_("Unmounting partitions..."), clear=False)
         swap = re.sub(
             "\\s",
@@ -88,21 +107,23 @@
                 capture_output=True,
             ).output,
         )
         if swap:
             execute(f"swapoff {swap} &>/dev/null", check=False)
 
         mounted_partitions = [
-            partition for partition in self.partitions if partition.part_mounted
+            partition for partition in self.partitions if partition.is_mounted()
         ]
         mounted_partitions.sort(
             key=lambda part: 0
             if not part.part_mount_point
             else len(part.part_mount_point),
             reverse=True,
         )
 
-        while True in [partition.part_mounted for partition in mounted_partitions]:
+        while not arguments.test() and True in [
+            partition.is_mounted() for partition in mounted_partitions
+        ]:
             for partition in [
-                partition for partition in mounted_partitions if partition.part_mounted
+                partition for partition in mounted_partitions if partition.is_mounted()
             ]:
                 partition.umount()
```

## archcraftsman/prelaunchinfo.py

```diff
@@ -15,56 +15,68 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The module of PreLaunchInfo class.
 """
 import os
 
-from archcraftsman.globalargs import GlobalArgs
-from archcraftsman.i18n import I18n
-from archcraftsman.utils import print_step, execute, log
+from archcraftsman.base import execute, log, print_step
+from archcraftsman.i18n import _
+from archcraftsman.options import Languages
 
-_ = I18n().gettext
+
+def parse_detected_language(detected_language: str) -> Languages:
+    """
+    The function to parse the detected language.
+    """
+    match detected_language:
+        case "fr-FR":
+            return Languages.FRENCH
+        case _:
+            return Languages.ENGLISH
 
 
 class PreLaunchInfo:
     """
     The class to contain all pre-launch information.
     """
 
-    global_language: str
-    keymap: str
-    detected_timezone: str
-    live_console_font: str
+    def __init__(
+        self,
+        global_language: Languages = Languages.ENGLISH,
+        keymap: str = "en",
+        detected_timezone: str = "Etc/UTC",
+        live_console_font: str = "",
+    ) -> None:
+        self.global_language = global_language
+        self.keymap = keymap
+        self.detected_timezone = detected_timezone
+        self.live_console_font = live_console_font
 
     def setup_locale(self):
         """
         The method to set up environment locale.
         """
         print_step(_("Configuring live environment..."), clear=False)
         self.live_console_font = "ter-v16b"
-        if GlobalArgs().install():
-            execute(f'loadkeys "{self.keymap}"')
-            execute("setfont ter-v16b")
-            dimensions = execute("stty size", capture_output=True).output
-            if dimensions:
-                split_dimensions = dimensions.split(" ")
-                if (
-                    split_dimensions
-                    and len(split_dimensions) > 0
-                    and int(split_dimensions[0]) >= 80
-                ):
-                    self.live_console_font = "ter-v32b"
-                    execute("setfont ter-v32b")
-        if self.global_language == "FR":
-            if GlobalArgs().install():
-                execute(
-                    'sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /etc/locale.gen'
-                )
-                execute("locale-gen")
+        execute(f'loadkeys "{self.keymap}"')
+        execute("setfont ter-v16b")
+        dimensions = execute("stty size", capture_output=True).output
+        if dimensions:
+            split_dimensions = dimensions.split(" ")
+            if (
+                split_dimensions
+                and len(split_dimensions) > 0
+                and int(split_dimensions[0]) >= 80
+            ):
+                self.live_console_font = "ter-v32b"
+                execute("setfont ter-v32b")
+        if self.global_language == Languages.FRENCH:
+            execute('sed -i "s|#fr_FR.UTF-8 UTF-8|fr_FR.UTF-8 UTF-8|g" /etc/locale.gen')
+            execute("locale-gen")
             os.putenv("LANG", "fr_FR.UTF-8")
             os.putenv("LANGUAGE", "fr_FR.UTF-8")
         else:
             os.putenv("LANG", "en_US.UTF-8")
             os.putenv("LANGUAGE", "en_US.UTF-8")
 
     def setup_chroot_keyboard(self):
```

## archcraftsman/shell.py

```diff
@@ -16,27 +16,30 @@
 
 """
 The shell mode module
 """
 from subprocess import CalledProcessError
 from typing import Optional
 
+from archcraftsman import config
+from archcraftsman.base import execute, print_error, print_step
+from archcraftsman.basesetup import pre_launch, setup_system
 from archcraftsman.bundles.bundle import Bundle
 from archcraftsman.bundles.utils import prompt_bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.options import Commands, Kernels, Desktops, Bundles, SubCommands
-from archcraftsman.utils import (
-    prompt_option,
-    print_error,
-    print_supported,
-    execute,
-    print_step,
+from archcraftsman.i18n import _
+from archcraftsman.manualpart import manual_partitioning
+from archcraftsman.options import (
+    Bundles,
+    Commands,
+    Desktops,
+    Kernels,
+    ShellBundles,
+    SubCommands,
 )
-
-_ = I18n().gettext
+from archcraftsman.utils import print_supported, prompt_option
 
 
 def ask_for_kernel() -> Optional[Bundle]:
     """
     A method to ask for a kernel.
     """
     try:
@@ -83,32 +86,54 @@
             Bundles.COPY_ACM,
             new_line_prompt=False,
         )
     except ValueError:
         return None
 
 
-def install_bundle(bundle):
+def ask_for_shell_bundle() -> Optional[Bundle]:
+    """
+    A method to ask for a bundle.
+    """
+    try:
+        return prompt_bundle(
+            "> ",
+            _("Shell bundle '%s' is not supported."),
+            ShellBundles,
+            _("Available shell bundles : "),
+            None,
+            new_line_prompt=False,
+        )
+    except ValueError:
+        return None
+
+
+def install_bundle(bundle: Bundle):
     """
     The method to install the bundle.
     """
-    match bundle.name:
-        case _:
-            if len(bundle.packages({})) > 0:
-                execute(f'pacman -S {" ".join(bundle.packages({}))}', check=False)
+    if bundle.is_aur():
+        bundle.configure()
+    else:
+        if len(bundle.packages()) > 0:
+            execute(
+                f'pacman -S {" ".join(bundle.packages())}',
+                check=False,
+            )
 
 
 def uninstall_bundle(bundle):
     """
     The method to uninstall the bundle.
     """
-    match bundle.name:
-        case _:
-            if len(bundle.packages({})) > 0:
-                execute(f'pacman -Rsnc {" ".join(bundle.packages({}))}', check=False)
+    if len(bundle.packages()) > 0:
+        execute(
+            f'pacman -Rsnc {" ".join(bundle.packages())}',
+            check=False,
+        )
 
 
 def shell():
     """
     The shell mode method.
     """
     print_step(_("ArchCraftsman interactive shell mode."))
@@ -128,21 +153,32 @@
             match command:
                 case Commands.KERNEL:
                     bundle = ask_for_kernel()
                 case Commands.DESKTOP:
                     bundle = ask_for_desktop()
                 case Commands.BUNDLE:
                     bundle = ask_for_bundle()
+                case Commands.SHELL_BUNDLE:
+                    bundle = ask_for_shell_bundle()
                 case Commands.HELP:
                     print_supported(_("Available commands :"), list(Commands))
                     continue
                 case Commands.EXIT:
                     want_exit = True
+                    config.serialize()
                     continue
 
+            if bundle and bundle.name == ShellBundles.GENERATE_CONFIG:
+                pre_launch()
+                setup_system()
+                partitioning_info_ok: bool = False
+                while not partitioning_info_ok:
+                    partitioning_info_ok = manual_partitioning(change_disks=False)
+                continue
+
             sub_command = prompt_option(
                 "> ",
                 _("Sub-command '%s' is not supported."),
                 SubCommands,
                 _("Available sub-commands : "),
                 None,
                 new_line_prompt=False,
@@ -151,19 +187,24 @@
             match sub_command:
                 case SubCommands.INSTALL:
                     if bundle:
                         install_bundle(bundle)
                 case SubCommands.UNINSTALL:
                     if bundle:
                         uninstall_bundle(bundle)
+                case SubCommands.CANCEL:
+                    continue
         except KeyboardInterrupt:
+            config.serialize()
             print_error(_("Script execution interrupted by the user !"), do_pause=False)
             want_exit = True
         except CalledProcessError as sub_process_exception:
+            config.serialize()
             print_error(
                 _("A subprocess execution failed ! See the following error: %s")
                 % sub_process_exception,
                 do_pause=False,
             )
             want_exit = True
         except EOFError:
+            config.serialize()
             want_exit = True
```

## archcraftsman/systeminfo.py

```diff
@@ -15,30 +15,92 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The module of SystemInfo class.
 """
 
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-
-_ = I18n().gettext
+from archcraftsman.options import BundleTypes, get_btype_by_name
 
 
 class SystemInfo:
     """
     The class to contain all system information.
     """
 
-    hostname: str
-    bundles: list[Bundle]
-    kernel: Bundle
-    desktop: Bundle
-    network: Bundle
-    bootloader: Bundle
-    micro_codes: Bundle
-    timezone: str
-    user_name: str
-    user_full_name: str
-    more_pkgs: set[str]
-    root_password: str
-    user_password: str
+    def __init__(
+        self,
+        hostname: str = "archlinux",
+        timezone: str = "Etc/UTC",
+        user_name: str = "",
+        user_full_name: str = "",
+        root_password: str = "",
+        user_password: str = "",
+    ) -> None:
+        self.hostname = hostname
+        self.bundles: list[Bundle] = []
+        self.timezone = timezone
+        self.user_name = user_name
+        self.user_full_name = user_full_name
+        self.more_pkgs: list[str] = []
+        self.root_password = root_password
+        self.user_password = user_password
+
+    def kernel(self) -> Bundle:
+        """
+        The kernel bundle retrieving method.
+        """
+        return next(
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.KERNEL
+        )
+
+    def microcode(self) -> Bundle:
+        """
+        The microcode bundle retrieving method.
+        """
+        return next(
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.MICRO_CODES
+        )
+
+    def bootloader(self) -> Bundle:
+        """
+        The bootloader bundle retrieving method.
+        """
+        return next(
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.BOOTLOADER
+        )
+
+    def desktop(self) -> Bundle:
+        """
+        The desktop bundle retrieving method.
+        """
+        return next(
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.DESKTOP
+        )
+
+    def network(self) -> Bundle:
+        """
+        The network bundle retrieving method.
+        """
+        return next(
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.NETWORK
+        )
+
+    def others(self) -> list[Bundle]:
+        """
+        The other bundles retrieving method.
+        """
+        return [
+            bundle
+            for bundle in self.bundles
+            if get_btype_by_name(bundle.name) == BundleTypes.OTHER
+        ]
```

## archcraftsman/utils.py

```diff
@@ -13,52 +13,46 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The general utility methods and tools module
 """
-import encodings
-import getpass
-import glob
-import os
 import re
 import readline
 import subprocess
+from importlib.resources import files
 from typing import Optional, TypeVar
 
-from archcraftsman.globalargs import GlobalArgs
-from archcraftsman.i18n import I18n
-from archcraftsman.options import FSFormats
-from archcraftsman.options import OptionEnum
+from archcraftsman.base import (
+    execute,
+    glob_completer,
+    print_error,
+    print_help,
+    print_step,
+    print_sub_step,
+    prompt,
+    prompt_ln,
+    prompt_passwd,
+)
+from archcraftsman.i18n import _
+from archcraftsman.options import FSFormats, OptionEnum
 
-RED = "\033[0;31m"
-GREEN = "\033[0;32m"
-CYAN = "\033[0;36m"
-ORANGE = "\033[0;33m"
-GRAY = "\033[0;37m"
-NOCOLOR = "\033[0m"
 
-_ = I18n().gettext
-
-
-def glob_completer(text, state) -> str:
-    """
-    The glob completer for readline completions.
-    """
-    return [
-        path + "/" if os.path.isdir(path) else path for path in glob.glob(text + "*")
-    ][state]
-
-
-def is_bios() -> bool:
+def generate_translations(global_language: str):
     """
-    Check if live system run on a bios.
+    Generate translations for ArchCraftsman.
     """
-    return not os.path.exists("/sys/firmware/efi")
+    locale_file_path = files("archcraftsman.locales").joinpath(f"{global_language}.po")
+    if locale_file_path.is_file():
+        execute(
+            f"msgfmt -o /usr/share/locale/fr/LC_MESSAGES/archcraftsman.mo {locale_file_path} &>/dev/null",
+            force=True,
+            sudo=True,
+        )
 
 
 def to_iec(size: int) -> str:
     """
     The method to convert a size in iec format.
     """
     return re.sub(
@@ -70,48 +64,154 @@
     )
 
 
 def from_iec(size: str) -> int:
     """
     The method to convert an iec formatted size in bytes.
     """
-    return int(
-        re.sub(
+    try:
+        value = re.sub(
             "\\s",
             "",
             execute(
                 f'printf "{size}" | numfmt --from=iec',
                 capture_output=True,
                 force=True,
             ).output,
         )
+        return int(value) if value else 0
+    except subprocess.CalledProcessError:
+        return 0
+
+
+def print_supported(supported_msg: str, options: list[str], *ignores: str):
+    """
+    A method to print all supported options.
+    """
+    supported_options = [option for option in options if option not in ignores]
+    print_step(supported_msg, clear=False)
+    print_sub_step(" ".join(supported_options))
+    print("")
+
+
+T = TypeVar("T", bound=OptionEnum)
+
+
+def prompt_option(
+    message: str,
+    error_msg: str,
+    options: type[T],
+    supported_msg: Optional[str],
+    default: Optional[T],
+    *ignores: T,
+    new_line_prompt: bool = True,
+) -> Optional[T]:
+    """
+    A method to prompt for a bundle.
+    """
+    readline.set_completer(
+        lambda text, state: (
+            [
+                option
+                for option in list(options)
+                if (not text or option.value.startswith(text)) and option not in ignores
+            ]
+            + [None]
+        )[state]
+    )
+    supported_options = [option for option in list(options) if option not in ignores]
+    if supported_msg:
+        print_supported(supported_msg, list(options), *ignores)
+    option_ok = False
+    option = None
+    while not option_ok:
+        prompt_message = message
+        if default:
+            prompt_message = message % default.value
+        if new_line_prompt:
+            option_name = prompt_ln(prompt_message, default=default).lower()
+        else:
+            option_name = prompt(prompt_message, default=default).lower()
+        if option_name in supported_options:
+            option_ok = True
+            option = options(option_name)
+        else:
+            print_error(error_msg % option_name, do_pause=False)
+            continue
+    readline.set_completer(glob_completer)
+    return option
+
+
+def ask_keymap(default: str) -> str:
+    """
+    A method to prompt for a keymap.
+    """
+    keymaps = (
+        execute(
+            "localectl list-keymaps",
+            capture_output=True,
+            force=True,
+        )
+        .output.strip()
+        .split("\n")
+    )
+    readline.set_completer(
+        lambda text, state: (
+            [
+                option
+                for option in keymaps + ["help"]
+                if (not text or option.lower().startswith(text.lower()))
+            ]
+            + [None]
+        )[state]
     )
+    keymap_ok = False
+    keymap = ""
+    while not keymap_ok:
+        prompt_message = (
+            _(
+                "Type your installation's keymap, or 'help' to get the list of keymaps (%s) : "
+            )
+            % default
+        )
+        keymap = prompt_ln(prompt_message, default=default).lower()
+        if keymap == "help":
+            print_help(" ".join(keymaps))
+            continue
+        if keymap in keymaps:
+            keymap_ok = True
+        else:
+            print_error(_("Keymap '%s' doesn't exist.") % keymap, do_pause=False)
+            continue
+    readline.set_completer(glob_completer)
+    return keymap
 
 
-def ask_format_type() -> Optional[FSFormats]:
+def ask_format_type() -> FSFormats:
     """
     The method to ask the user for the format type.
     """
-    return prompt_option(
+    format_type = prompt_option(
         _("Which format type do you want ? (%s) : "),
         _("Format type '%s' is not supported."),
         FSFormats,
         _("Supported format types : "),
         FSFormats.EXT4,
         FSFormats.VFAT,
     )
+    return format_type if format_type else FSFormats.EXT4
 
 
-def ask_encryption_block_name() -> Optional[str]:
+def ask_encryption_block_name() -> str:
     """
     Method to ask for encryption block name.
     """
     block_name_pattern = re.compile("^[a-z][a-z\\d_]*$")
     block_name_ok = False
-    block_name = None
+    block_name = ""
     while not block_name_ok:
         block_name = prompt_ln(
             _("What will be the encrypted block name ? : "), required=True
         )
         if block_name and not block_name_pattern.match(block_name):
             print_error(_("Invalid encrypted block name."))
             continue
@@ -131,20 +231,15 @@
             _("Enter it again to confirm : "), required=required
         )
         if password != password_confirm:
             print_error(_("Passwords entered don't match."))
     return password
 
 
-def ask_drive(
-    message: str,
-    error_msg: str,
-    supported_msg: Optional[str],
-    new_line_prompt: bool = True,
-) -> str:
+def ask_drive() -> str:
     """
     A method to prompt for a drive to partition.
     """
     drives = (
         execute(
             "lsblk -lpdno NAME,TYPE | grep disk | awk '{print $1}'",
             capture_output=True,
@@ -155,183 +250,33 @@
     )
     readline.set_completer(
         lambda text, state: (
             [option for option in drives if (not text or option.startswith(text))]
             + [None]
         )[state]
     )
-    if supported_msg:
-        print_supported(supported_msg, drives)
+    print_supported(_("Detected drives :"), drives)
     drive_ok = False
     drive = ""
     while not drive_ok:
-        prompt_message = message
-        if new_line_prompt:
-            drive = prompt_ln(prompt_message).lower()
-        else:
-            drive = prompt(prompt_message).lower()
+        prompt_message = _(
+            "On which drive should Archlinux be installed ? (type the entire name, for example '/dev/sda') : "
+        )
+        drive = prompt_ln(prompt_message).lower()
         if drive in drives:
             drive_ok = True
         else:
-            print_error(error_msg % drive, do_pause=False)
+            print_error(
+                _("The target drive '%s' doesn't exist.") % drive, do_pause=False
+            )
             continue
     readline.set_completer(glob_completer)
     return drive
 
 
-def print_error(message: str, do_pause: bool = True):
-    """
-    A method to print an error.
-    """
-    print(f"\n{RED}  /!\\ {message}{NOCOLOR}\n")
-    if do_pause:
-        pause(end_newline=True)
-
-
-def print_step(message: str, clear: bool = True):
-    """
-    A method to print a step message.
-    """
-    if clear:
-        execute("clear", force=True)
-    print(f"\n{GREEN}{message}{NOCOLOR}")
-
-
-def print_sub_step(message: str):
-    """
-    A method to print a sub step message.
-    """
-    print(f"{CYAN}  * {message}{NOCOLOR}")
-
-
-def log(message: str):
-    """
-    A method to print a log message.
-    """
-    if GlobalArgs().test():
-        print(f"{GRAY}> {message}{NOCOLOR}")
-
-
-def print_help(message: str, do_pause: bool = False):
-    """
-    A method to print an help message.
-    """
-    print_step(_("Help :"), clear=False)
-    print_sub_step(message)
-    if do_pause:
-        pause(end_newline=True)
-
-
-def input_str(message: str, password: bool = False) -> str:
-    """
-    A method to ask to input something.
-    """
-    if password:
-        return getpass.getpass(prompt=f"{ORANGE}{message}{NOCOLOR}")
-    return input(f"{ORANGE}{message}{NOCOLOR}")
-
-
-def prompt(
-    message: str,
-    default: Optional[str] = None,
-    help_msg: Optional[str] = None,
-    required: bool = False,
-    password: bool = False,
-) -> str:
-    """
-    A method to prompt for a user input.
-    """
-    user_input_ok = False
-    user_input = ""
-    while not user_input_ok:
-        user_input = input_str(f"{ORANGE}{message}{NOCOLOR}", password=password)
-        if user_input == "?" and help_msg:
-            print_help(help_msg)
-            continue
-        if not user_input and default:
-            user_input = default
-        if required and (user_input is None or not user_input):
-            print_error(_("The input must not be empty."))
-            continue
-        user_input_ok = True
-    return user_input
-
-
-def prompt_ln(
-    message: str,
-    default: Optional[str] = None,
-    help_msg: Optional[str] = None,
-    required: bool = False,
-) -> str:
-    """
-    A method to prompt for a user input with a new line for the user input.
-    """
-    return prompt(
-        f"{message}\n> ", default=default, help_msg=help_msg, required=required
-    )
-
-
-def print_supported(supported_msg: str, options: list[str], *ignores: str):
-    """
-    A method to print all supported options.
-    """
-    supported_options = [option for option in options if option not in ignores]
-    print_step(supported_msg, clear=False)
-    print_sub_step(", ".join(supported_options))
-    print("")
-
-
-T = TypeVar("T", bound=OptionEnum)
-
-
-def prompt_option(
-    message: str,
-    error_msg: str,
-    options: type[T],
-    supported_msg: Optional[str],
-    default: Optional[T],
-    *ignores: T,
-    new_line_prompt: bool = True,
-) -> Optional[T]:
-    """
-    A method to prompt for a bundle.
-    """
-    readline.set_completer(
-        lambda text, state: (
-            [
-                option
-                for option in list(options)
-                if (not text or option.value.startswith(text)) and option not in ignores
-            ]
-            + [None]
-        )[state]
-    )
-    supported_options = [option for option in list(options) if option not in ignores]
-    if supported_msg:
-        print_supported(supported_msg, list(options), *ignores)
-    option_ok = False
-    option = None
-    while not option_ok:
-        prompt_message = message
-        if default:
-            prompt_message = message % default.value
-        if new_line_prompt:
-            option_name = prompt_ln(prompt_message, default=default).lower()
-        else:
-            option_name = prompt(prompt_message, default=default).lower()
-        if option_name in supported_options:
-            option_ok = True
-            option = options(option_name)
-        else:
-            print_error(error_msg % option_name, do_pause=False)
-            continue
-    readline.set_completer(glob_completer)
-    return option
-
-
 def prompt_bool(
     message: str, default: bool = True, help_msg: Optional[str] = None
 ) -> bool:
     """
     A method to prompt for a boolean choice.
     """
     message += " ("
@@ -341,123 +286,7 @@
         message += f"{_('yes')[0]}/{_('no').upper()[0]}"
     if help_msg is not None:
         message += "/?"
     message += ") : "
     if not default:
         return prompt(f"{message}", help_msg=help_msg).upper() == _("yes").upper()[0]
     return prompt(f"{message}", help_msg=help_msg).upper() != _("no").upper()[0]
-
-
-def prompt_passwd(message: str, required: bool = False):
-    """
-    A method to prompt for a password without displaying an echo.
-    """
-    return prompt(f"{ORANGE}{message}{NOCOLOR}", required=required, password=True)
-
-
-def pause(start_newline: bool = False, end_newline: bool = False):
-    """
-    A method to insert a one key press pause.
-    """
-    message = _("Press any key to continue...")
-    if start_newline:
-        print("")
-    print(f"{ORANGE}{message}{NOCOLOR}")
-    execute("read -n 1 -sr", force=True)
-    if end_newline:
-        print("")
-
-
-class ExecutionResult:
-    """
-    A class to manage the result of an execution.
-    """
-
-    def __init__(self, command: str, result: subprocess.CompletedProcess):
-        self.command = command
-        self.output = (
-            ""
-            if not result.stdout
-            else result.stdout.decode(encodings.utf_8.getregentry().name)
-        )
-        self.returncode = result.returncode
-
-    def __bool__(self):
-        return self.returncode == 0
-
-    def __str__(self):
-        return self.output
-
-    def __repr__(self):
-        return self.output
-
-    def __eq__(self, other):
-        return (
-            self.command == other.command
-            and self.returncode == other.returncode
-            and self.output == other.output
-        )
-
-    def __ne__(self, other):
-        return (
-            self.command != other.command
-            or self.returncode != other.returncode
-            or self.output != other.output
-        )
-
-    def __hash__(self):
-        return hash(self.command) ^ hash(self.returncode) ^ hash(self.output)
-
-
-def execute(
-    command: str,
-    check: bool = True,
-    capture_output: bool = False,
-    force: bool = False,
-    sudo: bool = False,
-) -> ExecutionResult:
-    """
-    A method to exec a command.
-    """
-    if force or not GlobalArgs().test():
-        log(f"Real execution of: {command}")
-        if sudo and not sudo_exist() and not is_root():
-            raise PermissionError("This script must be run as root.")
-        if sudo and sudo_exist() and not is_root():
-            command = f"sudo {command}"
-        return ExecutionResult(
-            command,
-            subprocess.run(
-                command, shell=True, check=check, capture_output=capture_output
-            ),
-        )
-    log(f"Fake execution of: {command}")
-    return ExecutionResult(
-        command, subprocess.CompletedProcess(args=command, returncode=0, stdout=b"")
-    )
-
-
-def elevate() -> bool:
-    """
-    A method to elevate the current user to root.
-    """
-    if is_root():
-        return True
-    if sudo_exist():
-        execute("sudo -v", force=True)
-        return True
-    return False
-
-
-def sudo_exist() -> bool:
-    """
-    A method to check if sudo is installed.
-    """
-    return execute("which sudo", force=True, capture_output=True).returncode == 0
-
-
-def is_root() -> bool:
-    """
-    A method to check if the user is root.
-    """
-    user = execute("whoami", force=True, capture_output=True).output
-    return user.strip() == "root"
```

## archcraftsman/bundles/budgie.py

```diff
@@ -14,32 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The budgie bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Budgie(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "budgie-desktop",
             "budgie-desktop-view",
             "budgie-screensaver",
             "gnome-control-center",
             "gnome-terminal",
             "nautilus",
@@ -67,16 +64,11 @@
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/bundle.py

```diff
@@ -13,40 +13,43 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The generic bundle blueprint module
 """
-from archcraftsman.options import OptionEnum
 
 
 class Bundle:
     """
     A class to represent a bootloader.
     """
 
-    name: OptionEnum
-
-    def __init__(self, name: OptionEnum):
+    def __init__(self, name: str = ""):
         self.name = name
 
-    def packages(self, system_info) -> list[str]:  # pylint: disable=unused-argument
+    def packages(self) -> list[str]:
         """
         Bundle's packages retrieving method.
         """
         return []
 
+    def is_aur(self) -> bool:
+        """
+        Is Bundle AUR based.
+        """
+        return False
+
     def prompt_extra(self):
         """
         Bundle's extra options prompting method.
         """
 
     def print_resume(self):
         """
         Bundle's print resume method.
         """
 
-    def configure(self, system_info, pre_launch_info, partitioning_info):
+    def configure(self):
         """
         Bundle configuration method.
         """
```

## archcraftsman/bundles/cinnamon.py

```diff
@@ -14,32 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The cinnamon bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Cinnamon(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "cinnamon",
             "metacity",
             "gnome-shell",
             "gnome-terminal",
             "blueberry",
             "cinnamon-translations",
@@ -68,19 +65,14 @@
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
         execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/copyacm.py

```diff
@@ -13,42 +13,36 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The copy ArchCraftsman bundle module
 """
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import execute, print_sub_step
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class CopyACM(Bundle):
     """
     The CopyACM class.
     """
 
     def print_resume(self):
         print_sub_step(_("Copy ArchCraftsman to the new system."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
-        if system_info.user_name:
-            path = f"/home/{system_info.user_name}"
+    def configure(self):
+        if info.ai.system_info.user_name:
+            path = f"/home/{info.ai.system_info.user_name}"
             execute(f"mkdir -p /mnt{path}")
             execute(f"cp -r ~/archcraftsman /mnt{path}")
             execute(
-                f'arch-chroot /mnt bash -c "chown -R {system_info.user_name}:{system_info.user_name} {path}"'
+                (
+                    f'arch-chroot /mnt bash -c "chown -R {info.ai.system_info.user_name}:'
+                    f'{info.ai.system_info.user_name} {path}"'
+                )
             )
         else:
             path = "/root"
             execute(f"mkdir -p /mnt{path}")
             execute(f"cp -r ~/archcraftsman /mnt{path}")
```

## archcraftsman/bundles/cups.py

```diff
@@ -14,30 +14,25 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The cups bundle module
 """
 
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Cups(Bundle):
     """
     Cups class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return [
             "cups",
             "cups-pdf",
             "avahi",
             "samba",
             "foomatic-db-engine",
             "foomatic-db",
@@ -47,16 +42,11 @@
             "gutenprint",
             "ghostscript",
         ]
 
     def print_resume(self):
         print_sub_step(_("Install Cups."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable avahi-daemon"')
         execute('arch-chroot /mnt bash -c "systemctl enable cups"')
         execute('arch-chroot /mnt bash -c "systemctl enable cups-browsed"')
```

## archcraftsman/bundles/cutefish.py

```diff
@@ -14,32 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The cutefish bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Cutefish(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "cutefish",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "pavucontrol",
@@ -57,16 +54,11 @@
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(
             _("Display manager : %s") % ("SDDM" if self.display_manager else _("none"))
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/deepin.py

```diff
@@ -14,41 +14,40 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The deepin bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Deepin(Bundle):
     """
     Bundle class.
     """
 
     minimal = False
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "deepin",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
         ]
         if self.minimal is not True:
             packages.append("deepin-extra")
+        else:
+            packages.append("deepin-terminal")
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(_("Display manager : %s") % "LightDM")
         if self.minimal:
             print_sub_step(_("Install a minimal environment."))
@@ -58,18 +57,13 @@
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
         execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/enlightenment.py

```diff
@@ -14,30 +14,26 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The enlightenment bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Enlightenment(Bundle):
     """
     Bundle class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "enlightenment",
             "terminology",
             "xorg-server",
             "xorg-xinit",
             "alsa-utils",
             "pulseaudio",
@@ -48,15 +44,10 @@
         ]
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(_("Display manager : %s") % _("none"))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/gnome.py

```diff
@@ -14,32 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The gnome bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Gnome(Bundle):
     """
     Bundle class.
     """
 
     minimal = False
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "gnome",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "xdg-desktop-portal",
             "xdg-desktop-portal-gnome",
@@ -58,15 +55,10 @@
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable gdm"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/grmlzsh.py

```diff
@@ -14,38 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The grml zsh bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class GrmlZsh(Bundle):
     """
     Grml ZSH config class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["zsh", "zsh-completions", "grml-zsh-config"]
 
     def print_resume(self):
         print_sub_step(_("Install ZSH with GRML configuration."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "chsh --shell /bin/zsh"')
         execute(
-            f'arch-chroot /mnt bash -c "chsh --shell /bin/zsh {system_info.user_name}"'
+            f'arch-chroot /mnt bash -c "chsh --shell /bin/zsh {info.ai.system_info.user_name}"'
         )
```

## archcraftsman/bundles/grub.py

```diff
@@ -15,49 +15,43 @@
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The grub bundle module
 """
 import re
 
+from archcraftsman import info
+from archcraftsman.base import execute, is_bios
 from archcraftsman.bundles.bundle import Bundle
 from archcraftsman.options import FSFormats, PartTypes
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import is_bios, execute
 
 
 class Grub(Bundle):
     """
     The Grub Bootloader class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["grub"]
 
-    def configure(
-        self,
-        system_info: dict,
-        pre_launch_info: dict,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if is_bios():
             execute(
-                f'arch-chroot /mnt bash -c "grub-install --target=i386-pc {partitioning_info.main_disk}"'
+                f'arch-chroot /mnt bash -c "grub-install --target=i386-pc {info.ai.partitioning_info.main_disk}"'
             )
         else:
             execute(
                 'arch-chroot /mnt bash -c "grub-install --target=x86_64-efi --efi-directory=/boot/efi '
                 "--bootloader-id='Arch Linux'\""
             )
         execute(
             'sed -i "/^GRUB_CMDLINE_LINUX=.*/a GRUB_DISABLE_OS_PROBER=false" /mnt/etc/default/grub'
         )
 
-        if partitioning_info.root_partition.encrypted:
+        if info.ai.partitioning_info.root_partition().encrypted:
             hooks = execute(
                 "grep -e '^HOOKS' /mnt/etc/mkinitcpio.conf",
                 check=False,
                 capture_output=True,
             ).output.strip()
             pattern = re.compile(r"^HOOKS=\((.+)\)")
             hooks_match = pattern.search(hooks)
@@ -78,33 +72,36 @@
             pattern = re.compile(r'^GRUB_CMDLINE_LINUX_DEFAULT="(.+)"')
             grub_cmdline_match = pattern.search(grub_cmdline)
             if grub_cmdline_match:
                 extracted_grub_cmdline = grub_cmdline_match.group(1).split(" ")
             else:
                 extracted_grub_cmdline = []
             extracted_grub_cmdline.append(
-                f"cryptdevice=UUID={partitioning_info.root_partition.uuid}:root"
+                f"cryptdevice=UUID={info.ai.partitioning_info.root_partition().uuid()}:root"
             )
             processed_grub_cmdline = (
                 f"GRUB_CMDLINE_LINUX_DEFAULT=\"{' '.join(extracted_grub_cmdline)}\""
             )
             execute(
                 f"sed -i 's|{grub_cmdline}|{processed_grub_cmdline}|g' /mnt/etc/default/grub"
             )
 
         for partition in [
             part
-            for part in partitioning_info.partitions
+            for part in info.ai.partitioning_info.partitions
             if part.encrypted and part.part_type != PartTypes.ROOT
         ]:
             execute(
-                f'echo "{partition.block_name} UUID={partition.uuid} none" >> /mnt/etc/crypttab'
+                f'echo "{partition.block_name} UUID={partition.uuid()} none" >> /mnt/etc/crypttab'
             )
 
-        if partitioning_info.root_partition.part_format_type == FSFormats.EXT4:
+        if (
+            info.ai.partitioning_info.root_partition().part_format_type
+            == FSFormats.EXT4
+        ):
             execute(
                 'sed -i "s|GRUB_DEFAULT=.*|GRUB_DEFAULT=saved|g" /mnt/etc/default/grub'
             )
             execute(
                 'sed -i "/^GRUB_DEFAULT=.*/a GRUB_SAVEDEFAULT=true" /mnt/etc/default/grub'
             )
         execute('arch-chroot /mnt bash -c "grub-mkconfig -o /boot/grub/grub.cfg"')
```

## archcraftsman/bundles/i3.py

```diff
@@ -14,30 +14,26 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The i3 bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class I3(Bundle):
     """
     Bundle class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "i3",
             "rofi",
             "dmenu",
             "perl",
             "alacritty",
             "xorg-server",
@@ -53,15 +49,10 @@
         ]
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(_("Display manager : %s") % _("none"))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/iwd.py

```diff
@@ -14,39 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The network manager bundle module
 """
 
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
 from archcraftsman.bundles.systemdnet import SystemdNet
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Iwd(Bundle):
     """
     Grml ZSH config class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = ["iwd"]
         return packages
 
     def print_resume(self):
         print_sub_step(_("Install Iwd."))
         SystemdNet(self.name).print_resume()
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable iwd.service"')
-        SystemdNet(self.name).configure(system_info, pre_launch_info, partitioning_info)
+        SystemdNet(self.name).configure()
```

## archcraftsman/bundles/linux.py

```diff
@@ -13,62 +13,59 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 All supported linux kernel bundles module
 """
+from archcraftsman.base import print_sub_step
 from archcraftsman.bundles import bundle
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class LinuxCurrent(bundle.Bundle):
     """
     The Linux current kernel class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["linux", "linux-headers"]
 
     def print_resume(self):
         print_sub_step(_("Install Linux current kernel."))
 
 
 class LinuxHardened(Bundle):
     """
     The Linux hardened kernel class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["linux-hardened", "linux-hardened-headers"]
 
     def print_resume(self):
         print_sub_step(_("Install Linux hardened kernel."))
 
 
 class LinuxLts(bundle.Bundle):
     """
     The Linux LTS kernel class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["linux-lts", "linux-lts-headers"]
 
     def print_resume(self):
         print_sub_step(_("Install Linux LTS kernel."))
 
 
 class LinuxZen(bundle.Bundle):
     """
     The Linux zen kernel class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["linux-zen", "linux-zen-headers"]
 
     def print_resume(self):
         print_sub_step(_("Install Linux zen kernel."))
```

## archcraftsman/bundles/lxqt.py

```diff
@@ -14,32 +14,29 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The lxqt bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Lxqt(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "lxqt",
             "xorg-server",
             "breeze-icons",
             "xdg-utils",
             "xscreensaver",
             "xautolock",
@@ -67,16 +64,11 @@
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(
             _("Display manager : %s") % ("SDDM" if self.display_manager else _("none"))
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/mainfilesystems.py

```diff
@@ -13,20 +13,17 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The main file systems bundle module
 """
+from archcraftsman.base import print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 def get_main_file_systems() -> list[str]:
     """
     The method to get the package list of the main file systems group.
     """
     return [
@@ -45,12 +42,12 @@
 
 
 class MainFileSystems(Bundle):
     """
     The main file systems class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return get_main_file_systems()
 
     def print_resume(self):
         print_sub_step(_("Install main file systems support."))
```

## archcraftsman/bundles/mainfonts.py

```diff
@@ -13,20 +13,17 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The main fonts bundle module
 """
+from archcraftsman.base import print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 def get_main_fonts() -> list[str]:
     """
     The method to get the package list of the main fonts group.
     """
     return [
@@ -39,15 +36,15 @@
         "ttf-fira-code",
         "ttf-fira-mono",
         "ttf-fira-sans",
         "ttf-font-awesome",
         "ttf-inconsolata",
         "ttf-input",
         "ttf-liberation",
-        "ttf-nerd-fonts-symbols-2048-em",
+        "ttf-nerd-fonts-symbols",
         "ttf-opensans",
         "ttf-roboto",
         "ttf-roboto-mono",
         "ttf-ubuntu-font-family",
         "ttf-jetbrains-mono",
         "otf-font-awesome",
         "noto-fonts-emoji",
@@ -56,12 +53,12 @@
 
 
 class MainFonts(Bundle):
     """
     The main fonts class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return get_main_fonts()
 
     def print_resume(self):
         print_sub_step(_("Install a set of main fonts."))
```

## archcraftsman/bundles/mate.py

```diff
@@ -14,46 +14,45 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The mate bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Mate(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
     minimal = False
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "mate",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
         ]
         if self.display_manager:
             packages.extend(
                 ["lightdm", "lightdm-gtk-greeter", "lightdm-gtk-greeter-settings"]
             )
         if self.minimal is not True:
             packages.append("mate-extra")
+        else:
+            packages.append("mate-terminal")
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(
             _("Display manager : %s")
             % ("LightDM" if self.display_manager else _("none"))
@@ -71,19 +70,14 @@
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
         execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/microcodes.py

```diff
@@ -16,39 +16,35 @@
 
 """
 The microcodes auto-installation bundle module
 """
 import re
 from typing import Optional
 
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.options import Bundles
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Microcodes(Bundle):
     """
     The Microcodes class.
     """
 
-    def __init__(self):
-        super().__init__(Bundles.MICROCODES)
+    def __init__(self, name: str = ""):
+        super().__init__(name)
         cpu_info_vendor = execute(
             'grep </proc/cpuinfo "vendor" | uniq', force=True, capture_output=True
         ).output
         if cpu_info_vendor:
             self.microcode_name = re.sub("\\s+", "", cpu_info_vendor).split(":")[1]
         else:
-            self.microcode_name = None
+            self.microcode_name = ""
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         if self.microcode_name == "GenuineIntel":
             return ["intel-ucode"]
         if self.microcode_name == "AuthenticAMD":
             return ["amd-ucode"]
         return []
 
     def microcode_img(self) -> Optional[str]:
```

## archcraftsman/bundles/networkmanager.py

```diff
@@ -14,47 +14,38 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The network manager bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
+from archcraftsman.i18n import _
 from archcraftsman.options import Desktops
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
 
 
 class NetworkManager(Bundle):
     """
     Grml ZSH config class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = ["networkmanager"]
-        if system_info.desktop and system_info.desktop.name in [
+        if info.ai.system_info.desktop().name in [
             Desktops.BUDGIE,
             Desktops.I3,
             Desktops.LXQT,
             Desktops.MATE,
             Desktops.SWAY,
             Desktops.ENLIGHTENMENT,
             Desktops.XFCE,
         ]:
             packages.append("network-manager-applet")
         return packages
 
     def print_resume(self):
         print_sub_step(_("Install NetworkManager."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable NetworkManager"')
```

## archcraftsman/bundles/nvidia.py

```diff
@@ -13,28 +13,29 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The nvidia proprietary driver bundle module
 """
+from archcraftsman import info
+from archcraftsman.base import print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
+from archcraftsman.i18n import _
 from archcraftsman.options import Kernels
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step
-
-_ = I18n().gettext
 
 
 class NvidiaDriver(Bundle):
     """
     The Nvidia driver class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
-        if system_info.kernel and system_info.kernel.name == Kernels.LTS:
+    def packages(self) -> list[str]:
+        if (
+            info.ai.system_info.kernel()
+            and info.ai.system_info.kernel().name == Kernels.LTS
+        ):
             return ["nvidia-lts"]
         return ["nvidia"]
 
     def print_resume(self):
         print_sub_step(_("Install proprietary Nvidia driver."))
```

## archcraftsman/bundles/pipewire.py

```diff
@@ -13,28 +13,25 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The pipewire bundle module
 """
+from archcraftsman.base import print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class PipeWire(Bundle):
     """
     The PipeWire class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return [
             "pipewire",
             "pipewire-alsa",
             "pipewire-audio",
             "pipewire-jack",
             "pipewire-media-session",
             "pipewire-pulse",
```

## archcraftsman/bundles/plasma.py

```diff
@@ -14,51 +14,51 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The plasma bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
+from archcraftsman.i18n import _
 from archcraftsman.options import Bundles
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.utils import prompt_bool
 
 
 class Plasma(Bundle):
     """
     Bundle class.
     """
 
     minimal = False
     plasma_wayland = False
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "plasma",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "xdg-desktop-portal",
             "xdg-desktop-portal-kde",
         ]
         if self.plasma_wayland:
             packages.extend(["plasma-wayland-session", "qt5-wayland"])
-            if system_info.bundles and Bundles.NVIDIA in [
-                bundle.name for bundle in system_info.bundles
+            if info.ai.system_info.others() and Bundles.NVIDIA in [
+                bundle.name for bundle in info.ai.system_info.others()
             ]:
                 packages.append("egl-wayland")
             if self.minimal is not True:
                 packages.append("kde-applications")
+            else:
+                packages.append("konsole")
+
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(_("Display manager : %s") % "SDDM")
         if self.minimal:
             print_sub_step(_("Install a minimal environment."))
@@ -73,15 +73,10 @@
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
         self.plasma_wayland = prompt_bool(
             _("Install Wayland support for the plasma session ?"), default=False
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable sddm"')
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/sway.py

```diff
@@ -14,30 +14,26 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The sway bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Sway(Bundle):
     """
     Bundle class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "sway",
             "dmenu",
             "bemenu-wayland",
             "j4-dmenu-desktop",
             "foot",
             "grim",
@@ -69,17 +65,12 @@
         ]
         return packages
 
     def print_resume(self):
         print_sub_step(_("Desktop environment : %s") % self.name)
         print_sub_step(_("Display manager : %s") % _("none"))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute('arch-chroot /mnt bash -c "systemctl enable acpid"')
-        pre_launch_info.setup_chroot_keyboard()
-        if "fr" in pre_launch_info.keymap:
+        info.ai.pre_launch_info.setup_chroot_keyboard()
+        if "fr" in info.ai.pre_launch_info.keymap:
             execute("echo 'XKB_DEFAULT_LAYOUT=fr' >> /mnt/etc/environment")
```

## archcraftsman/bundles/systemdnet.py

```diff
@@ -14,38 +14,28 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The systemd network bundle module
 """
 
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class SystemdNet(Bundle):
     """
     Grml ZSH config class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["systemd-resolvconf"]
 
     def print_resume(self):
         print_sub_step(_("Enable systemd network stack."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute("ln -sf /run/systemd/resolve/stub-resolv.conf /mnt/etc/resolv.conf")
         execute("cp -r /etc/systemd/network /mnt/etc/systemd/")
         execute('arch-chroot /mnt bash -c "systemctl enable systemd-networkd"')
         execute('arch-chroot /mnt bash -c "systemctl enable systemd-resolved"')
```

## archcraftsman/bundles/terminus.py

```diff
@@ -14,37 +14,28 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The terminus console font bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class TerminusFont(Bundle):
     """
     The Terminus console font class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["terminus-font"]
 
     def print_resume(self):
         print_sub_step(_("Install terminus console font."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         execute(
-            f'echo "FONT={pre_launch_info.live_console_font}" >>/mnt/etc/vconsole.conf'
+            f'echo "FONT={info.ai.pre_launch_info.live_console_font}" >>/mnt/etc/vconsole.conf'
         )
```

## archcraftsman/bundles/utils.py

```diff
@@ -14,117 +14,138 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The bundles related utility methods and tools module
 """
 from typing import Optional, TypeVar
+
 from archcraftsman.bundles.budgie import Budgie
 from archcraftsman.bundles.bundle import Bundle
 from archcraftsman.bundles.cinnamon import Cinnamon
 from archcraftsman.bundles.copyacm import CopyACM
 from archcraftsman.bundles.cups import Cups
 from archcraftsman.bundles.cutefish import Cutefish
 from archcraftsman.bundles.deepin import Deepin
 from archcraftsman.bundles.enlightenment import Enlightenment
+from archcraftsman.bundles.generateconfig import GenerateConfig
 from archcraftsman.bundles.gnome import Gnome
 from archcraftsman.bundles.grmlzsh import GrmlZsh
 from archcraftsman.bundles.grub import Grub
 from archcraftsman.bundles.i3 import I3
 from archcraftsman.bundles.iwd import Iwd
-from archcraftsman.bundles.linux import LinuxCurrent, LinuxLts, LinuxZen, LinuxHardened
+from archcraftsman.bundles.linux import LinuxCurrent, LinuxHardened, LinuxLts, LinuxZen
 from archcraftsman.bundles.lxqt import Lxqt
 from archcraftsman.bundles.mainfilesystems import MainFileSystems
 from archcraftsman.bundles.mainfonts import MainFonts
 from archcraftsman.bundles.mate import Mate
 from archcraftsman.bundles.microcodes import Microcodes
 from archcraftsman.bundles.networkmanager import NetworkManager
 from archcraftsman.bundles.nvidia import NvidiaDriver
 from archcraftsman.bundles.pipewire import PipeWire
 from archcraftsman.bundles.plasma import Plasma
 from archcraftsman.bundles.sway import Sway
 from archcraftsman.bundles.systemdnet import SystemdNet
 from archcraftsman.bundles.terminus import TerminusFont
 from archcraftsman.bundles.xfce import Xfce
+from archcraftsman.bundles.yay import Yay
 from archcraftsman.bundles.zram import Zram
-from archcraftsman.options import Kernels, BootLoaders, Desktops, Bundles, Network
-from archcraftsman.options import OptionEnum
+from archcraftsman.options import (
+    BootLoaders,
+    Bundles,
+    Desktops,
+    Kernels,
+    Network,
+    OptionEnum,
+    ShellBundles,
+)
 from archcraftsman.utils import prompt_option
 
 
-def process_bundle(name: OptionEnum) -> Bundle:
+def get_bundle_type_by_name(name: str) -> type[Bundle]:
     """
-    Process a bundle name into a Bundle object.
+    A function to get the bundle type by its name.
     """
     match name:
         case Kernels.CURRENT:
-            bundle = LinuxCurrent(name)
+            bundle = LinuxCurrent
         case Kernels.LTS:
-            bundle = LinuxLts(name)
+            bundle = LinuxLts
         case Kernels.ZEN:
-            bundle = LinuxZen(name)
+            bundle = LinuxZen
         case Kernels.HARDENED:
-            bundle = LinuxHardened(name)
+            bundle = LinuxHardened
         case BootLoaders.GRUB:
-            bundle = Grub(name)
+            bundle = Grub
         case Desktops.GNOME:
-            bundle = Gnome(name)
+            bundle = Gnome
         case Desktops.PLASMA:
-            bundle = Plasma(name)
+            bundle = Plasma
         case Desktops.XFCE:
-            bundle = Xfce(name)
+            bundle = Xfce
         case Desktops.BUDGIE:
-            bundle = Budgie(name)
+            bundle = Budgie
         case Desktops.CINNAMON:
-            bundle = Cinnamon(name)
+            bundle = Cinnamon
         case Desktops.CUTEFISH:
-            bundle = Cutefish(name)
+            bundle = Cutefish
         case Desktops.DEEPIN:
-            bundle = Deepin(name)
+            bundle = Deepin
         case Desktops.LXQT:
-            bundle = Lxqt(name)
+            bundle = Lxqt
         case Desktops.MATE:
-            bundle = Mate(name)
+            bundle = Mate
         case Desktops.ENLIGHTENMENT:
-            bundle = Enlightenment(name)
+            bundle = Enlightenment
         case Desktops.I3:
-            bundle = I3(name)
+            bundle = I3
         case Desktops.SWAY:
-            bundle = Sway(name)
+            bundle = Sway
         case Network.NETWORK_MANAGER:
-            bundle = NetworkManager(name)
+            bundle = NetworkManager
         case Network.IWD:
-            bundle = Iwd(name)
+            bundle = Iwd
         case Network.SYSTEMD:
-            bundle = SystemdNet(name)
+            bundle = SystemdNet
         case Bundles.CUPS:
-            bundle = Cups(name)
+            bundle = Cups
         case Bundles.GRML:
-            bundle = GrmlZsh(name)
+            bundle = GrmlZsh
         case Bundles.MAIN_FILE_SYSTEMS:
-            bundle = MainFileSystems(name)
+            bundle = MainFileSystems
         case Bundles.MAIN_FONTS:
-            bundle = MainFonts(name)
+            bundle = MainFonts
         case Bundles.MICROCODES:
-            bundle = Microcodes()
+            bundle = Microcodes
         case Bundles.NVIDIA:
-            bundle = NvidiaDriver(name)
+            bundle = NvidiaDriver
         case Bundles.PIPEWIRE:
-            bundle = PipeWire(name)
+            bundle = PipeWire
         case Bundles.TERMINUS:
-            bundle = TerminusFont(name)
+            bundle = TerminusFont
         case Bundles.ZRAM:
-            bundle = Zram(name)
+            bundle = Zram
         case Bundles.COPY_ACM:
-            bundle = CopyACM(name)
+            bundle = CopyACM
+        case ShellBundles.YAY:
+            bundle = Yay
+        case ShellBundles.GENERATE_CONFIG:
+            bundle = GenerateConfig
         case _:
-            bundle = Bundle(name)
+            bundle = Bundle
     return bundle
 
 
+def process_bundle(name: OptionEnum) -> Bundle:
+    """
+    Process a bundle name into a Bundle object.
+    """
+    return get_bundle_type_by_name(name.value)(name)
+
+
 T = TypeVar("T", bound=OptionEnum)
 
 
 def prompt_bundle(
     message: str,
     error_msg: str,
     options: type[T],
```

## archcraftsman/bundles/xfce.py

```diff
@@ -14,33 +14,30 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The xfce bundle module
 """
 
+from archcraftsman import info
+from archcraftsman.base import execute, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, prompt_bool, execute
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
+from archcraftsman.utils import prompt_bool
 
 
 class Xfce(Bundle):
     """
     Bundle class.
     """
 
     display_manager = True
     minimal = False
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         packages = [
             "xfce4",
             "xorg-server",
             "alsa-utils",
             "pulseaudio",
             "pulseaudio-alsa",
             "pavucontrol",
@@ -72,19 +69,14 @@
             _("Install a minimal environment ?"),
             default=False,
             help_msg=_(
                 "If yes, the script will not install any extra packages, only base packages."
             ),
         )
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         if self.display_manager:
             execute('arch-chroot /mnt bash -c "systemctl enable lightdm"')
         execute(
             'sed -i "s|#logind-check-graphical=false|logind-check-graphical=true|g" /mnt/etc/lightdm/lightdm.conf'
         )
-        pre_launch_info.setup_chroot_keyboard()
+        info.ai.pre_launch_info.setup_chroot_keyboard()
```

## archcraftsman/bundles/zram.py

```diff
@@ -13,41 +13,31 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 """
 The zram bundle module
 """
+from archcraftsman.base import log, print_sub_step
 from archcraftsman.bundles.bundle import Bundle
-from archcraftsman.i18n import I18n
-from archcraftsman.partitioninginfo import PartitioningInfo
-from archcraftsman.prelaunchinfo import PreLaunchInfo
-from archcraftsman.systeminfo import SystemInfo
-from archcraftsman.utils import print_sub_step, log
-
-_ = I18n().gettext
+from archcraftsman.i18n import _
 
 
 class Zram(Bundle):
     """
     The ZRAM class.
     """
 
-    def packages(self, system_info: SystemInfo) -> list[str]:
+    def packages(self) -> list[str]:
         return ["zram-generator"]
 
     def print_resume(self):
         print_sub_step(_("Install and enable ZRAM."))
 
-    def configure(
-        self,
-        system_info: SystemInfo,
-        pre_launch_info: PreLaunchInfo,
-        partitioning_info: PartitioningInfo,
-    ):
+    def configure(self):
         content = ["[zram0]\n", "zram-size = ram / 2\n"]
         try:
             with open(
                 "/mnt/etc/systemd/zram-generator.conf", "w", encoding="UTF-8"
             ) as zram_config_file:
                 zram_config_file.writelines(content)
         except FileNotFoundError as exception:
```

## Comparing `archcraftsman/locales/fr.po` & `archcraftsman/locales/french.po`

 * *Files 2% similar despite different names*

```diff
@@ -1,299 +1,279 @@
 # SOME DESCRIPTIVE TITLE.
 # Copyright (C) YEAR ORGANIZATION
 # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
 #
 msgid ""
 msgstr ""
 "Project-Id-Version: \n"
-"POT-Creation-Date: 2023-03-24 22:38+0100\n"
-"PO-Revision-Date: 2023-03-24 22:38+0100\n"
+"POT-Creation-Date: 2023-03-30 23:31+0200\n"
+"PO-Revision-Date: 2023-03-30 23:34+0200\n"
 "Last-Translator: \n"
 "Language-Team: \n"
 "Language: fr_FR\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=2; plural=(n > 1);\n"
 "Generated-By: pygettext.py 1.5\n"
 "X-Generator: Poedit 3.2.2\n"
 
 #: archcraftsman/autopart.py:48
 msgid "Automatic partitioning :"
 msgstr "Partitionnement automatique :"
 
-#: archcraftsman/autopart.py:51 archcraftsman/manualpart.py:55
-msgid ""
-"On which drive should Archlinux be installed ? (type the entire name, for "
-"example '/dev/sda') : "
-msgstr ""
-"Sur quel disque Archlinux doit-il être installé ? (tapez le nom complet, par "
-"exemple '/dev/sda') : "
-
-#: archcraftsman/autopart.py:54 archcraftsman/manualpart.py:58
-msgid "The target drive '%s' doesn't exist."
-msgstr "Le disque cible '%s' n'existe pas."
-
-#: archcraftsman/autopart.py:55 archcraftsman/manualpart.py:59
-msgid "Detected drives :"
-msgstr "Disques détectés :"
-
-#: archcraftsman/autopart.py:68
+#: archcraftsman/autopart.py:62
 msgid "Do you want to install Arch Linux next to other systems ?"
 msgstr "Voulez-vous installer Arch Linux à côté des autres systèmes ?"
 
-#: archcraftsman/autopart.py:74
+#: archcraftsman/autopart.py:68
 msgid "What type of Swap do you want ? (%s) : "
 msgstr "Quel type de swap voulez-vous ? (%s) : "
 
-#: archcraftsman/autopart.py:75
+#: archcraftsman/autopart.py:69
 msgid "Swap type '%s' is not supported."
 msgstr "Le type de swap '%s' n'est pas supporté."
 
-#: archcraftsman/autopart.py:77
+#: archcraftsman/autopart.py:71
 msgid "Supported Swap types : "
 msgstr "Types de swap supportés : "
 
-#: archcraftsman/autopart.py:81
+#: archcraftsman/autopart.py:75
 msgid "Do you want a separated Home ?"
 msgstr "Voulez-vous un Home séparé ?"
 
-#: archcraftsman/autopart.py:85 archcraftsman/autopart.py:91
+#: archcraftsman/autopart.py:79 archcraftsman/autopart.py:85
 msgid "Do you want to encrypt the %s partition ?"
 msgstr "Voulez-vous chiffrer la partition %s ?"
 
-#: archcraftsman/autopart.py:265 archcraftsman/basesetup.py:118
-#: archcraftsman/basesetup.py:271 archcraftsman/manualpart.py:165
+#: archcraftsman/autopart.py:259 archcraftsman/basesetup.py:112
+#: archcraftsman/basesetup.py:266 archcraftsman/manualpart.py:159
 msgid "Summary of choices :"
 msgstr "Résumé des choix :"
 
-#: archcraftsman/autopart.py:269 archcraftsman/manualpart.py:173
+#: archcraftsman/autopart.py:263 archcraftsman/manualpart.py:167
 msgid "Swapfile size : %s"
 msgstr "Taille du fichier d'échange : %s"
 
-#: archcraftsman/autopart.py:270 archcraftsman/basesetup.py:123
-#: archcraftsman/basesetup.py:292 archcraftsman/manualpart.py:174
+#: archcraftsman/autopart.py:264 archcraftsman/basesetup.py:117
+#: archcraftsman/basesetup.py:287 archcraftsman/manualpart.py:168
 msgid "Is the information correct ?"
 msgstr "Les informations sont-elles correctes ?"
 
-#: archcraftsman/autopart.py:273 archcraftsman/manualpart.py:177
+#: archcraftsman/autopart.py:267 archcraftsman/manualpart.py:171
 msgid "Do you want to change the partitioning mode ?"
 msgstr "Voulez-vous changer de mode de partitionnement ?"
 
-#: archcraftsman/basesetup.py:61
+#: archcraftsman/basesetup.py:69
+msgid "Querying IP geolocation information..."
+msgstr "Interrogation des informations de géolocalisation IP..."
+
+#: archcraftsman/basesetup.py:89
 msgid "Welcome to ArchCraftsman !"
 msgstr "Bienvenue sur ArchCraftsman !"
 
-#: archcraftsman/basesetup.py:64
+#: archcraftsman/basesetup.py:92
 msgid ""
 "BIOS detected ! The script will act accordingly. Don't forget to select a "
 "DOS label type before partitioning."
 msgstr ""
 "BIOS détecté ! Le script agira en conséquence. N'oubliez pas de sélectionner "
 "un label type DOS avant de partitionner."
 
-#: archcraftsman/basesetup.py:70
+#: archcraftsman/basesetup.py:98
 msgid "Environment configuration : "
 msgstr "Configuration de l'environnement : "
 
-#: archcraftsman/basesetup.py:78
-msgid "Supported languages : "
-msgstr "Langues prises en charge : "
-
-#: archcraftsman/basesetup.py:86
+#: archcraftsman/basesetup.py:101
 msgid "Choose your installation's language (%s) : "
 msgstr "Choisissez la langue de votre installation (%s) : "
 
-#: archcraftsman/basesetup.py:93
+#: archcraftsman/basesetup.py:102
 msgid "Global language '%s' is not supported."
 msgstr "La langue globale '%s' n'est pas prise en charge."
 
-#: archcraftsman/basesetup.py:107
-msgid "Type your installation's keymap (%s) : "
-msgstr "Entrez la keymap de votre installation (%s) : "
-
-#: archcraftsman/basesetup.py:115
-msgid "Keymap %s doesn't exist."
-msgstr "La keymap %s n'existe pas."
+#: archcraftsman/basesetup.py:104
+msgid "Supported languages : "
+msgstr "Langues prises en charge : "
 
-#: archcraftsman/basesetup.py:120
+#: archcraftsman/basesetup.py:114
 msgid "Your installation's language : %s"
 msgstr "La langue de votre installation : %s"
 
-#: archcraftsman/basesetup.py:122
+#: archcraftsman/basesetup.py:116
 msgid "Your installation's keymap : %s"
 msgstr "La keymap de votre installation : %s"
 
-#: archcraftsman/basesetup.py:136
+#: archcraftsman/basesetup.py:131
 msgid "System configuration : "
 msgstr "Configuration du système : "
 
-#: archcraftsman/basesetup.py:138
+#: archcraftsman/basesetup.py:133
 msgid "What will be your hostname (archlinux) : "
 msgstr "Quel sera votre nom d'hôte (archlinux) : "
 
-#: archcraftsman/basesetup.py:143
+#: archcraftsman/basesetup.py:138
 msgid "Choose your kernel (%s) : "
 msgstr "Choisissez votre kernel (%s) : "
 
-#: archcraftsman/basesetup.py:144 archcraftsman/shell.py:45
+#: archcraftsman/basesetup.py:139 archcraftsman/shell.py:55
 msgid "Kernel '%s' is not supported."
 msgstr "Le kernel '%s' n'est pas supporté."
 
-#: archcraftsman/basesetup.py:146 archcraftsman/shell.py:47
+#: archcraftsman/basesetup.py:141 archcraftsman/shell.py:57
 msgid "Supported kernels : "
 msgstr "Kernels pris en charge : "
 
-#: archcraftsman/basesetup.py:151
+#: archcraftsman/basesetup.py:146
 msgid "Install a desktop environment ? (%s) : "
 msgstr "Installer un environnement de bureau ? (%s) : "
 
-#: archcraftsman/basesetup.py:152 archcraftsman/shell.py:62
+#: archcraftsman/basesetup.py:147 archcraftsman/shell.py:72
 msgid "Desktop environment '%s' is not supported."
 msgstr "L'environnement de bureau '%s' n'est pas pris en charge."
 
-#: archcraftsman/basesetup.py:154 archcraftsman/shell.py:64
+#: archcraftsman/basesetup.py:149 archcraftsman/shell.py:74
 msgid "Supported desktop environments : "
 msgstr "Environnements de bureau supportés : "
 
-#: archcraftsman/basesetup.py:159
+#: archcraftsman/basesetup.py:154
 msgid "Choose your network stack (%s) : "
 msgstr "Choisissez votre pile réseau (%s) : "
 
-#: archcraftsman/basesetup.py:160
+#: archcraftsman/basesetup.py:155
 msgid "Network stack '%s' is not supported."
 msgstr "La pile réseau '%s' n'est pas supporté."
 
-#: archcraftsman/basesetup.py:162
+#: archcraftsman/basesetup.py:157
 msgid "Supported network stacks : "
 msgstr "Pile réseau supportés : "
 
-#: archcraftsman/basesetup.py:166
+#: archcraftsman/basesetup.py:161
 msgid "Install proprietary Nvidia driver ?"
 msgstr "Installer le pilote propriétaire Nvidia ?"
 
-#: archcraftsman/basesetup.py:169
+#: archcraftsman/basesetup.py:164
 msgid "Install terminus console font ?"
 msgstr "Installer la police de console Terminus ?"
 
-#: archcraftsman/basesetup.py:172
+#: archcraftsman/basesetup.py:167
 msgid "Install Cups ?"
 msgstr "Installer Cups ?"
 
-#: archcraftsman/basesetup.py:176
+#: archcraftsman/basesetup.py:171
 msgid "Install ZSH with GRML configuration ?"
 msgstr "Installer ZSH avec la configuration GRML ?"
 
-#: archcraftsman/basesetup.py:178
+#: archcraftsman/basesetup.py:173
 msgid ""
 "If yes, the script will install the ZSH shell with GRML configuration. GRML "
 "is a ZSH pre-configuration used by Archlinux's live environment."
 msgstr ""
 "Si oui, le script installera le shell ZSH avec la configuration GRML. GRML "
 "est une pré-configuration de ZSH utilisée par l'environnement live "
 "d'Archlinux."
 
-#: archcraftsman/basesetup.py:187
+#: archcraftsman/basesetup.py:182
 msgid "Install a set of main fonts ?"
 msgstr "Installer un ensemble de polices principales ?"
 
-#: archcraftsman/basesetup.py:189 archcraftsman/basesetup.py:197
+#: archcraftsman/basesetup.py:184 archcraftsman/basesetup.py:192
 msgid ""
 "If yes, the following packages will be installed :\n"
 "%s"
 msgstr ""
 "Si oui, les paquets suivants seront installés :\n"
 "%s"
 
-#: archcraftsman/basesetup.py:195
+#: archcraftsman/basesetup.py:190
 msgid "Install main file systems support ?"
 msgstr "Installer le support des systèmes de fichiers principaux ?"
 
-#: archcraftsman/basesetup.py:203
+#: archcraftsman/basesetup.py:198
 msgid "Install and enable ZRAM ?"
 msgstr "Installer et activer ZRAM ?"
 
-#: archcraftsman/basesetup.py:205
+#: archcraftsman/basesetup.py:200
 msgid ""
 "ZRAM is a process to compress datas directly in the RAM instead of moving "
 "them in a swap. Enabled ZRAM will allow you to compress up to half of your "
 "RAM before having to swap. This method is more efficient than the swap and "
 "do not use your disk but is more CPU demanding. ZRAM is fully compatible "
 "with a swap, it just has a higher priority."
 msgstr ""
 "ZRAM est un procédé permettant de compresser les données directement dans la "
 "RAM au lieu de les déplacer dans un swap. L'activation de ZRAM vous "
 "permettra de compresser jusqu'à la moitié de votre RAM avant de devoir swap. "
 "Cette méthode est plus efficace que le swap et n'utilise pas votre disque "
 "mais est plus gourmande en ressources CPU. ZRAM est entièrement compatible "
 "avec un swap, il a juste une priorité plus élevée."
 
-#: archcraftsman/basesetup.py:215
+#: archcraftsman/basesetup.py:210
 msgid "Install PipeWire ?"
 msgstr "Installer PipeWire ?"
 
-#: archcraftsman/basesetup.py:217
+#: archcraftsman/basesetup.py:212
 msgid ""
 "If yes, the PipeWire multimedia framework will be installed to manage audio "
 "and video capture."
 msgstr ""
 "Si oui, le framework multimédia PipeWire sera installé pour gérer l'audio et "
 "la capture vidéo."
 
-#: archcraftsman/basesetup.py:224
+#: archcraftsman/basesetup.py:219
 msgid "Copy ArchCraftsman to the new system ?"
 msgstr "Copier ArchCraftsman sur le nouveau système ?"
 
-#: archcraftsman/basesetup.py:229
+#: archcraftsman/basesetup.py:224
 msgid "Your timezone (%s) : "
 msgstr "Votre fuseau horaire (%s) : "
 
-#: archcraftsman/basesetup.py:236
+#: archcraftsman/basesetup.py:231
 msgid "Would you like to add a user? (type username, leave blank if none) : "
 msgstr ""
 "Voulez-vous ajouter un utilisateur ? (tapez le nom d'utilisateur, laissez "
 "vide si vous n'en avez pas) : "
 
-#: archcraftsman/basesetup.py:244
+#: archcraftsman/basesetup.py:239
 msgid "Invalid user name."
 msgstr "Nom d'utilisateur invalide."
 
-#: archcraftsman/basesetup.py:250
+#: archcraftsman/basesetup.py:245
 msgid ""
 "What is the %s's full name (type the entire full name, leave blank if "
 "none) : "
 msgstr ""
 "Quel est le nom complet de %s (tapez le nom complet, laissez un blanc si "
 "vous n'en avez pas) : "
 
-#: archcraftsman/basesetup.py:258 archcraftsman/basesetup.py:263
+#: archcraftsman/basesetup.py:253 archcraftsman/basesetup.py:258
 msgid "%s password configuration : "
 msgstr "Configuration du mot de passe de %s : "
 
-#: archcraftsman/basesetup.py:260 archcraftsman/basesetup.py:265
+#: archcraftsman/basesetup.py:255 archcraftsman/basesetup.py:260
 msgid "Enter the %s password : "
 msgstr "Entrez le mot de passe de %s : "
 
-#: archcraftsman/basesetup.py:272
+#: archcraftsman/basesetup.py:267
 msgid "Your hostname : %s"
 msgstr "Votre nom d'hôte : %s"
 
-#: archcraftsman/basesetup.py:283
+#: archcraftsman/basesetup.py:278
 msgid "Your timezone : %s"
 msgstr "Votre fuseau horaire : %s"
 
-#: archcraftsman/basesetup.py:285
+#: archcraftsman/basesetup.py:280
 msgid "Additional user name : %s"
 msgstr "Nom d'utilisateur supplémentaire : %s"
 
-#: archcraftsman/basesetup.py:287
+#: archcraftsman/basesetup.py:282
 msgid "User's full name : %s"
 msgstr "Nom complet de l'utilisateur : %s"
 
-#: archcraftsman/basesetup.py:290
+#: archcraftsman/basesetup.py:285
 msgid "More packages to install : %s"
 msgstr "Plus de paquets à installer : %s"
 
 #: archcraftsman/bundles/budgie.py:62 archcraftsman/bundles/cinnamon.py:63
 #: archcraftsman/bundles/cutefish.py:53 archcraftsman/bundles/lxqt.py:63
 #: archcraftsman/bundles/mate.py:66 archcraftsman/bundles/xfce.py:67
 msgid "The display manager to install is '%s'. Do you want to install it ?"
@@ -414,159 +394,167 @@
 msgid "Enable systemd network stack."
 msgstr "Activer la pile réseau de systemd."
 
 #: archcraftsman/bundles/terminus.py:40
 msgid "Install terminus console font."
 msgstr "Installer la police de console Terminus."
 
+#: archcraftsman/bundles/yay.py:25
+msgid "Install YAY."
+msgstr "Installer YAY."
+
+#: archcraftsman/bundles/yay.py:29
+msgid "You must not be root to install yay."
+msgstr "Vous devez ne pas être root pour installer yay."
+
 #: archcraftsman/bundles/zram.py:39
 msgid "Install and enable ZRAM."
 msgstr "Installer et activer ZRAM."
 
-#: archcraftsman/disk.py:115
+#: archcraftsman/disk.py:116
 msgid "Swapfile size ? (%s, type '0' for none) : "
 msgstr "Taille du fichier d'échange ? (%s, tapez '0' pour aucun) : "
 
-#: archcraftsman/installer.py:59
+#: archcraftsman/installer.py:58
 msgid "Partitioning :"
 msgstr "Partitionnement :"
 
-#: archcraftsman/installer.py:61
+#: archcraftsman/installer.py:60
 msgid "Do you want an automatic partitioning ?"
 msgstr "Voulez-vous un partitionnement automatique ?"
 
-#: archcraftsman/installer.py:70
+#: archcraftsman/installer.py:69
 msgid "Updating mirrors..."
 msgstr "Mise à jour des miroirs..."
 
-#: archcraftsman/installer.py:128
+#: archcraftsman/installer.py:127
 msgid "Installation of the base..."
 msgstr "Installation de la base..."
 
-#: archcraftsman/installer.py:131
+#: archcraftsman/installer.py:130
 msgid "System configuration..."
 msgstr "Configuration du système..."
 
-#: archcraftsman/installer.py:157
+#: archcraftsman/installer.py:156
 msgid "Locales configuration..."
 msgstr "Configuration des locales..."
 
-#: archcraftsman/installer.py:163
+#: archcraftsman/installer.py:162
 msgid "Installation of the remaining packages..."
 msgstr "Installation des paquets restants..."
 
-#: archcraftsman/installer.py:177
+#: archcraftsman/installer.py:176
 msgid "Creation and activation of the swapfile..."
 msgstr "Création et activation du fichier d'échange..."
 
-#: archcraftsman/installer.py:196
+#: archcraftsman/installer.py:195
 msgid "Generating fstab..."
 msgstr "Génération du fstab..."
 
-#: archcraftsman/installer.py:200
+#: archcraftsman/installer.py:199
 msgid "Desktop configuration..."
 msgstr "Configuration du bureau..."
 
-#: archcraftsman/installer.py:206
+#: archcraftsman/installer.py:205
 msgid "Network configuration..."
 msgstr "Configuration du réseau..."
 
-#: archcraftsman/installer.py:214
+#: archcraftsman/installer.py:213
 msgid "Installation and configuration of the grub..."
 msgstr "Installation et configuration du grub..."
 
-#: archcraftsman/installer.py:219
+#: archcraftsman/installer.py:218
 msgid "Users configuration..."
 msgstr "Configuration des utilisateurs..."
 
-#: archcraftsman/installer.py:220
+#: archcraftsman/installer.py:219
 msgid "Root account configuration..."
 msgstr "Configuration du compte Root..."
 
-#: archcraftsman/installer.py:226
+#: archcraftsman/installer.py:225
 msgid "%s account configuration..."
 msgstr "Configuration du compte %s..."
 
-#: archcraftsman/installer.py:245
+#: archcraftsman/installer.py:244
 msgid "Extra packages configuration if needed..."
 msgstr "Configuration de paquets supplémentaires si nécessaire..."
 
-#: archcraftsman/installer.py:252
+#: archcraftsman/installer.py:251
 msgid "Installation complete ! You can reboot your system."
 msgstr "L'installation est terminée ! Vous pouvez redémarrer votre système."
 
-#: archcraftsman/installer.py:256 archcraftsman/installer.py:306
-#: archcraftsman/shell.py:159
+#: archcraftsman/installer.py:255 archcraftsman/installer.py:293
+#: archcraftsman/shell.py:189
 msgid "Script execution interrupted by the user !"
 msgstr "Exécution du script interrompue par l'utilisateur !"
 
-#: archcraftsman/installer.py:261 archcraftsman/installer.py:310
-#: archcraftsman/shell.py:163
+#: archcraftsman/installer.py:260 archcraftsman/installer.py:297
+#: archcraftsman/shell.py:193
 msgid "A subprocess execution failed ! See the following error: %s"
 msgstr ""
 "L'exécution d'un sous-processus a échoué ! L'erreur suivante s'est "
 "produite : %s"
 
-#: archcraftsman/installer.py:275
+#: archcraftsman/installer.py:276
+msgid "This script must be run as root."
+msgstr "Ce script doit être exécuté en tant que root."
+
+#: archcraftsman/installer.py:279
 msgid "Running pre-launch steps : "
 msgstr "Exécution des étapes de pré-lancement : "
 
 #: archcraftsman/installer.py:287
 msgid "Synchronising repositories..."
 msgstr "Synchronisation des dépôts..."
 
-#: archcraftsman/installer.py:291
-msgid "Querying IP geolocation information..."
-msgstr "Interrogation des informations de géolocalisation IP..."
-
-#: archcraftsman/manualpart.py:49 archcraftsman/manualpart.py:64
+#: archcraftsman/manualpart.py:49 archcraftsman/manualpart.py:58
 msgid "Manual partitioning :"
 msgstr "Partitionnement manuel :"
 
-#: archcraftsman/manualpart.py:51 archcraftsman/manualpart.py:66
+#: archcraftsman/manualpart.py:51 archcraftsman/manualpart.py:60
 msgid "Partitioned drives so far : %s"
 msgstr "Disques partitionnés jusqu'à présent : %s"
 
-#: archcraftsman/manualpart.py:70
+#: archcraftsman/manualpart.py:64
 msgid "Do you want to partition an other drive ?"
 msgstr "Voulez-vous partitionner un autre disque ?"
 
-#: archcraftsman/manualpart.py:83
+#: archcraftsman/manualpart.py:77
 msgid "Detected target drive partitions : %s"
 msgstr "Partitions du disque cible détectées : %s"
 
-#: archcraftsman/manualpart.py:89
+#: archcraftsman/manualpart.py:83
 msgid "Partition :"
 msgstr "Partition :"
 
-#: archcraftsman/manualpart.py:93 archcraftsman/manualpart.py:102
+#: archcraftsman/manualpart.py:87 archcraftsman/manualpart.py:96
 msgid "What is the role of this partition ? (%s) : "
 msgstr "Quel est le rôle de cette partition ? (%s) : "
 
-#: archcraftsman/manualpart.py:94 archcraftsman/manualpart.py:103
+#: archcraftsman/manualpart.py:88 archcraftsman/manualpart.py:97
 msgid "Partition type '%s' is not supported."
 msgstr "Le type de partition '%s' n'est pas supporté."
 
-#: archcraftsman/manualpart.py:96 archcraftsman/manualpart.py:105
+#: archcraftsman/manualpart.py:90 archcraftsman/manualpart.py:99
 msgid "Supported partition types : "
 msgstr "Types de partition supportés : "
 
-#: archcraftsman/manualpart.py:129
+#: archcraftsman/manualpart.py:123
 msgid "What is the mounting point of this partition ? : "
 msgstr "Quel est le point de montage de cette partition ? : "
 
-#: archcraftsman/manualpart.py:137
+#: archcraftsman/manualpart.py:131
 msgid "The EFI partition is required for system installation."
 msgstr "La partition EFI est nécessaire pour l'installation du système."
 
-#: archcraftsman/manualpart.py:144
+#: archcraftsman/manualpart.py:138
 msgid "The Root partition is required for system installation."
 msgstr "La partition Root est nécessaire pour l'installation du système."
 
-#: archcraftsman/manualpart.py:154
+#: archcraftsman/manualpart.py:148
 msgid "The Boot partition is required for system installation."
 msgstr "La partition Boot est nécessaire pour l'installation du système."
 
 #: archcraftsman/packages.py:93
 msgid ""
 "Install more packages ? (type extra packages full names, example : 'htop "
 "neofetch', leave blank if none) : "
@@ -579,139 +567,174 @@
 msgid "Package %s doesn't exist."
 msgstr "Le paquet %s n'existe pas."
 
 #: archcraftsman/partition.py:146
 msgid "Format the partition ?"
 msgstr "Formater la partition ?"
 
-#: archcraftsman/partition.py:175
+#: archcraftsman/partition.py:179
 msgid "Do you want to encrypt this partition ?"
 msgstr "Voulez-vous chiffrer cette partition ?"
 
-#: archcraftsman/partition.py:190 archcraftsman/utils.py:339
-#: archcraftsman/utils.py:341 archcraftsman/utils.py:346
+#: archcraftsman/partition.py:194 archcraftsman/utils.py:373
+#: archcraftsman/utils.py:375 archcraftsman/utils.py:380
 msgid "yes"
 msgstr "oui"
 
-#: archcraftsman/partition.py:192 archcraftsman/utils.py:339
-#: archcraftsman/utils.py:341 archcraftsman/utils.py:347
+#: archcraftsman/partition.py:196 archcraftsman/utils.py:373
+#: archcraftsman/utils.py:375 archcraftsman/utils.py:381
 msgid "no"
 msgstr "non"
 
-#: archcraftsman/partition.py:199
+#: archcraftsman/partition.py:203
 msgid "%s : %s"
 msgstr "%s : %s"
 
-#: archcraftsman/partition.py:200
+#: archcraftsman/partition.py:204
 msgid "%s : %s (mounting point : %s, format %s, format type %s)"
 msgstr "%s : %s (point de montage : %s, formater %s, type de formatage %s)"
 
-#: archcraftsman/partition.py:208
+#: archcraftsman/partition.py:212
 msgid "encrypted"
 msgstr "chiffrée"
 
-#: archcraftsman/partition.py:222
+#: archcraftsman/partition.py:226
 msgid "Formatting %s..."
 msgstr "Formatage de %s..."
 
-#: archcraftsman/partition.py:230
+#: archcraftsman/partition.py:234
 msgid "Opening %s..."
 msgstr "Ouverture de %s..."
 
-#: archcraftsman/partition.py:247
+#: archcraftsman/partition.py:251
 msgid "Mounting %s..."
 msgstr "Montage de %s..."
 
-#: archcraftsman/partition.py:264
+#: archcraftsman/partition.py:268
 msgid "Unmounting %s..."
 msgstr "Démontage de %s..."
 
-#: archcraftsman/partition.py:267
+#: archcraftsman/partition.py:271
 msgid "Closing %s..."
 msgstr "Fermeture de %s..."
 
-#: archcraftsman/partitioninginfo.py:50
+#: archcraftsman/partitioninginfo.info.py:50
 msgid "Formatting and mounting partitions..."
 msgstr "Formatage et montage des partitions..."
 
-#: archcraftsman/partitioninginfo.py:81
+#: archcraftsman/partitioninginfo.info.py:81
 msgid "Unmounting partitions..."
 msgstr "Démontage des partitions..."
 
-#: archcraftsman/prelaunchinfo.py:43
+#: archcraftsman/prelaunchinfo.info.py:54
 msgid "Configuring live environment..."
 msgstr "Configuration de l'environnement live..."
 
-#: archcraftsman/shell.py:79
+#: archcraftsman/shell.py:89
 msgid "Bundle '%s' is not supported."
 msgstr "Le bundle '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:81
+#: archcraftsman/shell.py:91
 msgid "Available bundles : "
 msgstr "Bundles disponibles : "
 
-#: archcraftsman/shell.py:114
+#: archcraftsman/shell.py:107
+msgid "Shell bundle '%s' is not supported."
+msgstr "Le bundle shell '%s' n'est pas supporté."
+
+#: archcraftsman/shell.py:109
+msgid "Available shell bundles : "
+msgstr "Bundles shell disponibles : "
+
+#: archcraftsman/shell.py:140
 msgid "ArchCraftsman interactive shell mode."
 msgstr "Mode shell interactif d'ArchCraftsman."
 
-#: archcraftsman/shell.py:115 archcraftsman/shell.py:136
+#: archcraftsman/shell.py:141 archcraftsman/shell.py:164
 msgid "Available commands :"
 msgstr "Commandes disponibles :"
 
-#: archcraftsman/shell.py:121
+#: archcraftsman/shell.py:147
 msgid "Command '%s' is not supported."
 msgstr "La commande '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:144
+#: archcraftsman/shell.py:172
 msgid "Sub-command '%s' is not supported."
 msgstr "La sous-commande '%s' n'est pas supporté."
 
-#: archcraftsman/shell.py:146
+#: archcraftsman/shell.py:174
 msgid "Available sub-commands : "
 msgstr "Sous-commandes disponibles : "
 
-#: archcraftsman/utils.py:95
+#: archcraftsman/utils.py:206
+msgid "Press any key to continue..."
+msgstr "Appuyez sur n'importe quelle touche pour continuer..."
+
+#: archcraftsman/utils.py:252
+msgid "Help :"
+msgstr "Aide :"
+
+#: archcraftsman/utils.py:287
+msgid "The input must not be empty."
+msgstr "La saisie ne doit pas être vide."
+
+#: archcraftsman/utils.py:418
+msgid ""
+"Type your installation's keymap, or 'help' to get the list of keymaps (%s) : "
+msgstr ""
+"Entrez la keymap de votre installation, ou 'help' pour obtenir la liste des "
+"keymaps (%s) : "
+
+#: archcraftsman/utils.py:430
+msgid "Keymap '%s' doesn't exist."
+msgstr "La keymap '%s' n'existe pas."
+
+#: archcraftsman/utils.py:441
 msgid "Which format type do you want ? (%s) : "
 msgstr "Quel type de formatage voulez-vous ? (%s) : "
 
-#: archcraftsman/utils.py:96
+#: archcraftsman/utils.py:442
 msgid "Format type '%s' is not supported."
 msgstr "Le type de formatage '%s' n'est pas supporté."
 
-#: archcraftsman/utils.py:98
+#: archcraftsman/utils.py:444
 msgid "Supported format types : "
 msgstr "Types de formatage supportés : "
 
-#: archcraftsman/utils.py:113
+#: archcraftsman/utils.py:459
 msgid "What will be the encrypted block name ? : "
 msgstr "Quel sera le nom de bloc chiffré ? : "
 
-#: archcraftsman/utils.py:116
+#: archcraftsman/utils.py:462
 msgid "Invalid encrypted block name."
 msgstr "Nom de bloc chiffré invalide."
 
-#: archcraftsman/utils.py:131
+#: archcraftsman/utils.py:477
 msgid "Enter it again to confirm : "
 msgstr "Saisissez le à nouveau pour confirmer : "
 
-#: archcraftsman/utils.py:134
+#: archcraftsman/utils.py:480
 msgid "Passwords entered don't match."
 msgstr "Les mots de passe saisis ne correspondent pas."
 
-#: archcraftsman/utils.py:218
-msgid "Help :"
-msgstr "Aide :"
+#: archcraftsman/utils.py:503
+msgid "Detected drives :"
+msgstr "Disques détectés :"
 
-#: archcraftsman/utils.py:253
-msgid "The input must not be empty."
-msgstr "La saisie ne doit pas être vide."
+#: archcraftsman/utils.py:507
+msgid ""
+"On which drive should Archlinux be installed ? (type the entire name, for "
+"example '/dev/sda') : "
+msgstr ""
+"Sur quel disque Archlinux doit-il être installé ? (tapez le nom complet, par "
+"exemple '/dev/sda') : "
 
-#: archcraftsman/utils.py:361
-msgid "Press any key to continue..."
-msgstr "Appuyez sur n'importe quelle touche pour continuer..."
+#: archcraftsman/utils.py:515
+msgid "The target drive '%s' doesn't exist."
+msgstr "Le disque cible '%s' n'existe pas."
 
 #~ msgid "You need to choose a target drive."
 #~ msgstr "Vous devez choisir un disque cible."
 
 #~ msgid ""
 #~ "Which drive do you want to partition ? (type the entire name, for example "
 #~ "'/dev/sda') : "
```

## Comparing `archcraftsman-3.5.9.dist-info/LICENSE.txt` & `archcraftsman-4.0.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `archcraftsman-3.5.9.dist-info/NOTICES` & `archcraftsman-4.0.1.dist-info/NOTICES`

 * *Files identical despite different names*

## Comparing `archcraftsman-3.5.9.dist-info/RECORD` & `archcraftsman-4.0.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,55 +1,64 @@
 archcraftsman/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/autopart.py,sha256=vVDji73iA6DmUdJ-Eh3T7IGyOzE4RznfGnWX8Et1wWc,11926
-archcraftsman/basesetup.py,sha256=e5btWjdv9CtlwgR4YW0z9_N7xxV3KQa6G_SkDpWjUQY,11771
-archcraftsman/disk.py,sha256=8qSkW2bN2IIyTt3p6SW71eaFQA29OCvOo0JsZNcTYP4,4345
-archcraftsman/globalargs.py,sha256=gwK3BPt3IHFY1k3It8XAYp8HuWvbQiLDNIYzKgID0xY,2580
-archcraftsman/i18n.py,sha256=e-XxjJsvpAKTTHUZ7ORKbbTemWSlWnv81LxvzgUtPvw,2233
-archcraftsman/installer.py,sha256=9wEe0kPOjG1UphVHggUndoVgSl6EBAwRaV1WWYRTA5E,13132
-archcraftsman/manualpart.py,sha256=7Hz3uODrxBkGDXppYuUJpfBDUzNtYNW0OyW_eisgQXk,7450
-archcraftsman/options.py,sha256=jCFPYiraRBfwa1ZzqcyZ8S9nMJuWFBiBrLpcuugHHvs,3037
-archcraftsman/packages.py,sha256=bCYkigdWx2QnPs67ju1_5m41ulunRBxumhOun4gTFdI,3378
-archcraftsman/partition.py,sha256=mjHp_LilgmGUzwBbJcH5BZKpWsmPQWU2PJiTRYRbONc,10602
-archcraftsman/partitioninginfo.py,sha256=JpwI1RudPneWtIlxYhFGrqtyNbZdJx5EzS_lk0fxLtI,3470
-archcraftsman/prelaunchinfo.py,sha256=_Q5xiIL2YaW7GMQryi_I7rIukh0ZMnP0GZIl4S-zXs8,3254
-archcraftsman/shell.py,sha256=ER39SGom_gwPqXTorNo7gFI6etME1KIJ_bMwpPs5G0U,4938
-archcraftsman/systeminfo.py,sha256=SEAObWVAw0bR4BTgYonxQct2WFQHKdVPIYASl2_M-MA,1245
-archcraftsman/utils.py,sha256=SRmFrWRJiXM8ekVnn-xvxyZngrmRO1RxlzalTosU3to,12423
+archcraftsman/__main__.py,sha256=c1gTlf2A2vV5kqYk6kCKOQXEQgOovd9fZ6N0X6qX55o,828
+archcraftsman/arguments.py,sha256=7K-86jh4qxy1DowBmp2U79fIt33clbWzzWl7d3TBx3U,1904
+archcraftsman/autopart.py,sha256=CHBurAWJ6QsXizrs12ZnPhxkuNPfdbLp_qluz2p8uOM,11383
+archcraftsman/base.py,sha256=BKvA8MeonG0JYSZ-mi9Tm2qZLwl88G3XXtFI9IEokj0,6720
+archcraftsman/basesetup.py,sha256=9RES73P71OCT6rm2VBMUuFyc37Jbx3u8ogcZi8j69ho,12635
+archcraftsman/config.py,sha256=oWEPOjai92Pasa_nruf5wBebf-dK1KOTTBQUDkIbUuY,5314
+archcraftsman/disk.py,sha256=o7Agvf7EZfym-waxtmBVTrG5ZjYxZ5V-_m62DiFBRQI,4444
+archcraftsman/i18n.py,sha256=6dRcuu7dxpjck3kC1Ek9-5PrHho0zIaRTtSMd4g_frs,1449
+archcraftsman/info.py,sha256=y2IxUda9Rk_k47OguRpVNgdaUuils8Vwz6ZYtW9Kjjs,1281
+archcraftsman/installer.py,sha256=s1sPUmpUE3zi7AhcszQJszVMjrevZ-zi7eZv5XC6iAo,11235
+archcraftsman/manualpart.py,sha256=p0PljqJ9jNDYSBfI2To1DmdbLTGNo4sSTJUsdLNk7q4,7320
+archcraftsman/options.py,sha256=wqtNBMb21BzZZIvV0r4Dch-LaAyeHZzbG4wUpf-LaG4,3984
+archcraftsman/packages.py,sha256=qKrK3c9oBbt7AeUGIRFCf97rUwhO5vja6Ql8i7fgjBs,3335
+archcraftsman/partition.py,sha256=asqmYBh6ah2YCiR81o4vLTbDIeYIrwMaeR9LufhORsU,10496
+archcraftsman/partitioninginfo.py,sha256=pAhAwa8Wsyfc2Uj6ItYA6-SC4ueGdU5eoaWbBFOv_Gk,4299
+archcraftsman/prelaunchinfo.py,sha256=YKTb_FVfqSAI9aC4xVw2OmkBSN43mF-VWnglRoNPQA4,3638
+archcraftsman/shell.py,sha256=hEVRM861ZhvgTU3BbrTJGEKu_pPcNbs_mZOU7MNzSvI,6180
+archcraftsman/systeminfo.py,sha256=hfbqew28lpAe-T60YH5aZ2TdWk1imYuTNfSb6xb0wtQ,3116
+archcraftsman/utils.py,sha256=Tnc-FnVBm7DHTKRqUyT4U9KGPJLjrwOOd0cxufOiJeo,8407
 archcraftsman/bundles/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/bundles/budgie.py,sha256=0mDgXhs0Sg4Zqwxq2LfcrL46jOtZmNJLCzrVhk2nB18,2616
-archcraftsman/bundles/bundle.py,sha256=nrUbPEP2c1yfzn0W60uD16a0ayV5_UA0jTk7yiAREuY,1485
-archcraftsman/bundles/cinnamon.py,sha256=sAlOFm0udY6uEhTYPrb22qAolBcYjiBLYafppj60rzs,2765
-archcraftsman/bundles/copyacm.py,sha256=7jRzs58jYJ1gvcOuMwVzremGnsVhV-us9d6g6Gy8xdY,1893
-archcraftsman/bundles/cups.py,sha256=uZjZEX-l9SzBicJeoFhYwUgJBVSJZ_bEhtYrY0e5u6U,1997
-archcraftsman/bundles/cutefish.py,sha256=akbBguS9Wu488JsFOrIU15YFtXqp7jWslXFfk7tb6dI,2287
-archcraftsman/bundles/deepin.py,sha256=fPBKn40XOI8OtY76T4KYSrHkmeHJQRYB2P-i0q8LJaQ,2463
-archcraftsman/bundles/enlightenment.py,sha256=YLl9LltuCBDrb4cWUlifAddJyNNotkkxQ2D1mj7Gm2s,1989
-archcraftsman/bundles/gnome.py,sha256=H30pwLlnH-w4Y4pmcxRBIZerwL6hFWIhVg7tmvGTBDU,2294
-archcraftsman/bundles/grmlzsh.py,sha256=ezSWgnzvJVkdAis-esL_eLE3NgNUv2Hqz31zYXL4-SQ,1720
-archcraftsman/bundles/grub.py,sha256=EvWBsit8RctWy4Sg2S_sPG8abWQI9uwlkMpoaNdn0Ms,4284
-archcraftsman/bundles/i3.py,sha256=yHcdORuBnglH4kSGGtqgMld2ZKNdQIhKIaQi9VBptH4,2063
-archcraftsman/bundles/iwd.py,sha256=-R7KdUILIH8xW74ord3ZH6j8_zJ_WmsDjzkvJCuTMHE,1771
-archcraftsman/bundles/linux.py,sha256=WsLtCvLinr3pTShGIqsjLY3aIVvVWrdNaFFlvBX6Zgg,2157
-archcraftsman/bundles/lxqt.py,sha256=lYngVSIEvvG0GQHCm714iAMO7FDCAH5XjofbpKpIjHA,2545
-archcraftsman/bundles/mainfilesystems.py,sha256=hm5YiZKYLtmzzqqqP3MlnOgtOAvje-Thkc42CTa6olk,1640
-archcraftsman/bundles/mainfonts.py,sha256=ldl4XMEy-VvFbZxd-Grsd2_dHwK7gCvcrWDIqb2Si5Q,1931
-archcraftsman/bundles/mate.py,sha256=KdDb9uC6Aqqp0xkhI4MjyiFcJY_LqlZOJXc8VSkBHVY,2943
-archcraftsman/bundles/microcodes.py,sha256=ezw3C7wyQFI_F3nV-kQOSK7lpXOqlvsnU_9urrVBds4,2265
-archcraftsman/bundles/networkmanager.py,sha256=6jH3bmRAjh8B7jMVaHKHHlq5Rf4OtGv3KzInRteuq6U,1988
-archcraftsman/bundles/nvidia.py,sha256=TH0glAqm_omNwOrH3bDuQpVxUZvNTeL3ix6Oc3TPXbo,1391
-archcraftsman/bundles/pipewire.py,sha256=xcOqmpQzmqvNuQFlKhsx5Nb64JKZ2K7GgBYfgsRjNrc,1474
-archcraftsman/bundles/plasma.py,sha256=1jUrUfYZ04AblGJ3UVKY4h5DMeELBvquzLqDWLnQMGY,3001
-archcraftsman/bundles/sway.py,sha256=PBYEJ23DB_Ze2t-cUbt15Dz8Rxg_XVbKJsJROBl9VaQ,2629
-archcraftsman/bundles/systemdnet.py,sha256=warbEHe16_ynxNCEHgYAT-fOgv-QUUscJd1Wqzyb6KA,1826
-archcraftsman/bundles/terminus.py,sha256=i2exTXhq3h3p3HhXW7CK0INC0o5o-lTa7HnpjnCmiMg,1646
-archcraftsman/bundles/utils.py,sha256=2O0r4gCxFu_HLcOBys6hXlts7z-Kr-E3BeHGRSv2VGE,5241
-archcraftsman/bundles/xfce.py,sha256=7sy75eVr2kgt-iJU6V-U1a6e8w22b_ppZ3d4yrZfsOA,2974
-archcraftsman/bundles/zram.py,sha256=Lu5Ysz_tcex9O9_zXzrR1z9wHYhRIgBtR7B3aF_lMmY,1828
+archcraftsman/bundles/budgie.py,sha256=QwBgW3A2oDEwQQFVJ1eV18MM5PgXaJ28t9QLr5Qyy9M,2342
+archcraftsman/bundles/bundle.py,sha256=i-KG_1qL6WytbtqKbqvNnHaHoQqQmRTOlQrGPK9dKzA,1424
+archcraftsman/bundles/cinnamon.py,sha256=yraMYdRnO3Td700f-1vYda2PBsMMPcSPk3wwWsNqHCc,2491
+archcraftsman/bundles/copyacm.py,sha256=GlH9iCNvCieC8mikUC0xyMFV3FxA3egjhXmhsD9MSeo,1701
+archcraftsman/bundles/cups.py,sha256=_jj9WGTDgkAYcdEWYQIttgFkXkqjYnKTV3oKocWXN-M,1653
+archcraftsman/bundles/cutefish.py,sha256=eMCFQh1S9ucnhP56RyoAsk-OOPU_Wx1eklzIujz9hxc,2013
+archcraftsman/bundles/deepin.py,sha256=cpgSp5stwrPmDocUnZ4PMJiBKS69fjNUKw9VUMs-s04,2250
+archcraftsman/bundles/enlightenment.py,sha256=lyv7dIq9REta8bE_qoZVP8XtY9gVu_4MYq8ezIT4_QI,1684
+archcraftsman/bundles/generateconfig.py,sha256=7XLiNff29chYSKAvCrJ3mIjQjfjOWMlSz8RUubyP_8w,1066
+archcraftsman/bundles/gnome.py,sha256=FMmAmFmvqJD1PlgN_ofdqahrnpSJ_CxKmZWEMXX4t2o,2020
+archcraftsman/bundles/grmlzsh.py,sha256=oBgGJYZaLmQlOhWIp7GSakafJcL1iVgLQnpyTBL36y0,1415
+archcraftsman/bundles/grub.py,sha256=TqVX04GkVIKPUWTmqLVqyRZUdEvZKFhqP3nAZm63jU0,4149
+archcraftsman/bundles/i3.py,sha256=fSO8Y21Dvx0UrFU8kdBsddjh5dSXPAwky2YlRpNpGH8,1758
+archcraftsman/bundles/iwd.py,sha256=DsO6-d4AFdKDwuj0vV7xQpqPOBcHseiNXDagkTbwYEU,1380
+archcraftsman/bundles/linux.py,sha256=jMwlWUx89JeaHWZDgU7ZrYrtffGJIjO9Q9N1HtS_L4o,1985
+archcraftsman/bundles/lxqt.py,sha256=6ZDT1dypATMXqS-zneUqLcHQSC75uZNeyDm2maUMSVg,2271
+archcraftsman/bundles/mainfilesystems.py,sha256=atOPGk2hhGn99feYEp9AQROH_O78czrpSFQ6UybRhfs,1543
+archcraftsman/bundles/mainfonts.py,sha256=kCch3KLDkYJMbsyb7yeudz_ctNo2ZznbI_OeZOjIqkE,1826
+archcraftsman/bundles/mate.py,sha256=RdeLuJtJV2OwuDl8o-blAZvpvcHDGxIu11SOyQ1BImE,2728
+archcraftsman/bundles/microcodes.py,sha256=n91KKEFLZPYUU3J40wXGeyAq7h8sjNO57aoRQ2fxoU4,2126
+archcraftsman/bundles/networkmanager.py,sha256=F5-YbBa6la1zkvBqP6vyjZ7QziDIYE5_E18idzgdF2k,1661
+archcraftsman/bundles/nvidia.py,sha256=fkaD4CXe5JR9fcdSo4Tyis84tNH433vHxVsuXdN8D4E,1381
+archcraftsman/bundles/pipewire.py,sha256=hSNAvc-4lJCrga2LsPeV6RfP44q1NfQFUtgDUwMM1xA,1377
+archcraftsman/bundles/plasma.py,sha256=BVhwWld-5t3ui32isp1jlG01sYms5yYBcC3CCwNnivM,2807
+archcraftsman/bundles/sway.py,sha256=8AklWCMclesFc74vA910onRiNCRRR77IBNIgCfDSb0s,2332
+archcraftsman/bundles/systemdnet.py,sha256=gV5xxxWZhKQvX_1zy_Dktflpj1ZSP8dEgc4rNoaBVYA,1482
+archcraftsman/bundles/terminus.py,sha256=ssZqBmT78AaDpv7m0swLPrCqDYYdkfXFW9-bpNgIpak,1341
+archcraftsman/bundles/utils.py,sha256=doeNJxnIdqAYbBy7JmXzXwfObLZG0tQBWwYeblgYTfU,5493
+archcraftsman/bundles/xfce.py,sha256=Dxcx2_-2DCpNZWlTgLfVI7rMZIzAwczlcECqgcz7byo,2700
+archcraftsman/bundles/yay.py,sha256=58tS7xNWYnVdPply2e3aWZDR31JK-2corLBV9816nTY,1427
+archcraftsman/bundles/zram.py,sha256=hJk5gCcRoV_QGX2H64t06pGB_HPeDZ_VyaYFmHJC-LM,1484
 archcraftsman/locales/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
-archcraftsman/locales/fr.po,sha256=rUKG2VcBB-qjMwL80UHs_iLjHQHh_wpx-HjRIu8LMRk,28630
-archcraftsman-3.5.9.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-archcraftsman-3.5.9.dist-info/METADATA,sha256=XTtt7C_1501uhyhsjJbydave0bmh91HivxiH260jBlI,42432
-archcraftsman-3.5.9.dist-info/NOTICES,sha256=dh7GS8sAUlwVN5rx9yzBYNKqtd-u_G-8VJsoVJn4CKY,704
-archcraftsman-3.5.9.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-archcraftsman-3.5.9.dist-info/entry_points.txt,sha256=DMRX0bSeIHU5fLAcml9jf2BGwO7IfzFYOa52zDAAlac,63
-archcraftsman-3.5.9.dist-info/top_level.txt,sha256=rI1QWoDRjsPsuYEgU7TEyglkfmoRuMKiHD4AU1hn4zg,14
-archcraftsman-3.5.9.dist-info/RECORD,,
+archcraftsman/locales/french.po,sha256=rxk_lhi5-lMGyr0FO61NxC3dZfCkHGPxws7-zoZuKW8,29220
+archcraftsman/test/__init__.py,sha256=5ep5_AjU9ewXaak2P7VgAxiYKn3coX2Zc3Tn9k6Qx-E,732
+archcraftsman/test/test_base.py,sha256=UkSQSHnHlHhfB9l4ujmiucjaXJC2IfhkVkqwKy87kUI,10466
+archcraftsman/test/test_utils.py,sha256=OdTalMW5HdFsx8UIr5N1kJU2CQmObACpiJMpOWobpHk,2858
+archcraftsman-4.0.1.dist-info/LICENSE.txt,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+archcraftsman-4.0.1.dist-info/METADATA,sha256=5mmWyCkOe4kQWwBGr3Ctif82NNLTuFaadnr4IdaUVzI,10484
+archcraftsman-4.0.1.dist-info/NOTICES,sha256=dh7GS8sAUlwVN5rx9yzBYNKqtd-u_G-8VJsoVJn4CKY,704
+archcraftsman-4.0.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+archcraftsman-4.0.1.dist-info/entry_points.txt,sha256=DMRX0bSeIHU5fLAcml9jf2BGwO7IfzFYOa52zDAAlac,63
+archcraftsman-4.0.1.dist-info/top_level.txt,sha256=rI1QWoDRjsPsuYEgU7TEyglkfmoRuMKiHD4AU1hn4zg,14
+archcraftsman-4.0.1.dist-info/RECORD,,
```

