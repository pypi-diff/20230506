# Comparing `tmp/tsutsuji_trackcomputer-1.5.4-py3-none-any.whl.zip` & `tmp/tsutsuji_trackcomputer-1.6.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 53200 bytes, number of entries: 21
+Zip file size: 58077 bytes, number of entries: 21
 -rw-r--r--  2.0 unx        0 b- defN 21-Aug-22 02:52 tsutsuji/__init__.py
 -rw-r--r--  2.0 unx      647 b- defN 21-Sep-01 10:48 tsutsuji/__main__.py
--rw-r--r--  2.0 unx       22 b- defN 23-Mar-19 02:06 tsutsuji/_version.py
+-rw-r--r--  2.0 unx       22 b- defN 23-May-06 01:49 tsutsuji/_version.py
 -rw-r--r--  2.0 unx    26141 b- defN 22-Sep-11 03:22 tsutsuji/backimg.py
 -rw-r--r--  2.0 unx     5514 b- defN 22-Nov-23 06:36 tsutsuji/config.py
 -rw-r--r--  2.0 unx     2155 b- defN 22-Apr-09 01:12 tsutsuji/cui2.py
--rw-r--r--  2.0 unx     4040 b- defN 23-Mar-19 02:06 tsutsuji/curvetrackplot.py
+-rw-r--r--  2.0 unx     5753 b- defN 23-May-06 01:49 tsutsuji/curvetrackplot.py
 -rw-r--r--  2.0 unx    17026 b- defN 22-Sep-11 03:22 tsutsuji/drawcursor.py
--rw-r--r--  2.0 unx    19787 b- defN 23-Jan-29 05:22 tsutsuji/gui_tsutsuji.py
+-rw-r--r--  2.0 unx    19787 b- defN 23-May-06 01:49 tsutsuji/gui_tsutsuji.py
 -rw-r--r--  2.0 unx     5060 b- defN 22-Sep-11 03:22 tsutsuji/kml2track.py
 -rw-r--r--  2.0 unx     5551 b- defN 22-Nov-23 06:36 tsutsuji/kp_offset.py
--rw-r--r--  2.0 unx    12989 b- defN 22-Sep-11 03:22 tsutsuji/math.py
--rw-r--r--  2.0 unx    37896 b- defN 23-Mar-19 02:06 tsutsuji/measure.py
--rw-r--r--  2.0 unx     8619 b- defN 22-Sep-11 03:22 tsutsuji/solver.py
--rw-r--r--  2.0 unx    34854 b- defN 23-Jan-29 04:43 tsutsuji/track_control.py
+-rw-r--r--  2.0 unx    13102 b- defN 23-May-06 01:49 tsutsuji/math.py
+-rw-r--r--  2.0 unx    28724 b- defN 23-May-06 01:49 tsutsuji/measure.py
+-rw-r--r--  2.0 unx    69046 b- defN 23-May-06 01:49 tsutsuji/solver.py
+-rw-r--r--  2.0 unx    34854 b- defN 23-May-06 01:49 tsutsuji/track_control.py
 -rw-r--r--  2.0 unx    10318 b- defN 22-Sep-11 03:22 tsutsuji/trackwindow.py
--rw-r--r--  2.0 unx     9723 b- defN 23-Mar-19 02:08 tsutsuji_trackcomputer-1.5.4.dist-info/LICENSE
--rw-r--r--  2.0 unx     3464 b- defN 23-Mar-19 02:08 tsutsuji_trackcomputer-1.5.4.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Mar-19 02:08 tsutsuji_trackcomputer-1.5.4.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-Mar-19 02:08 tsutsuji_trackcomputer-1.5.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1701 b- defN 23-Mar-19 02:08 tsutsuji_trackcomputer-1.5.4.dist-info/RECORD
-21 files, 205608 bytes uncompressed, 50458 bytes compressed:  75.5%
+-rw-r--r--  2.0 unx     9723 b- defN 23-May-06 02:04 tsutsuji_trackcomputer-1.6.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3468 b- defN 23-May-06 02:04 tsutsuji_trackcomputer-1.6.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-06 02:04 tsutsuji_trackcomputer-1.6.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-May-06 02:04 tsutsuji_trackcomputer-1.6.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1702 b- defN 23-May-06 02:04 tsutsuji_trackcomputer-1.6.0.dist-info/RECORD
+21 files, 258694 bytes uncompressed, 55335 bytes compressed:  78.6%
```

## zipnote {}

```diff
@@ -42,23 +42,23 @@
 
 Filename: tsutsuji/track_control.py
 Comment: 
 
 Filename: tsutsuji/trackwindow.py
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.5.4.dist-info/LICENSE
+Filename: tsutsuji_trackcomputer-1.6.0.dist-info/LICENSE
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.5.4.dist-info/METADATA
+Filename: tsutsuji_trackcomputer-1.6.0.dist-info/METADATA
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.5.4.dist-info/WHEEL
+Filename: tsutsuji_trackcomputer-1.6.0.dist-info/WHEEL
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.5.4.dist-info/top_level.txt
+Filename: tsutsuji_trackcomputer-1.6.0.dist-info/top_level.txt
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.5.4.dist-info/RECORD
+Filename: tsutsuji_trackcomputer-1.6.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tsutsuji/_version.py

```diff
@@ -1 +1 @@
-__version__ = '1.5.4'
+__version__ = '1.6.0'
```

## tsutsuji/curvetrackplot.py

```diff
@@ -23,20 +23,20 @@
 
 from . import math
 
 class trackplot():
     def __init__(self):
         self.curvegen = trackcoordinate.curve()
         self.result=np.array([[0,0]])
-    def generate(self,A,phiA,phiB,Radius,lenTC1,lenTC2,tranfunc):
+    def generate(self,A,phiA,phiB,Radius,lenTC1,lenTC2,tranfunc,R0=0):
         delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
         
         if(lenTC1>0):
             tc1_tmp = self.curvegen.transition_curve(lenTC1,\
-                                          0,\
+                                          R0,\
                                           Radius,\
                                           0,\
                                           tranfunc,n=10) # 入口側の緩和曲線
         else:
             tc1_tmp=(np.array([[0,0]]),0,0)
             
         if(lenTC2>0):
@@ -58,22 +58,59 @@
         
         self.result = np.vstack((np.array([0,0]),tc1_tmp[0]))
         self.result = np.vstack((self.result,self.result[-1] + cc_tmp[0]))
         self.result = np.vstack((self.result,self.result[-1] + np.dot(self.curvegen.rotate(phi_tc2), tc2_tmp[0].T).T))
         
         self.result = np.dot(self.curvegen.rotate(phiA), self.result.T).T
         self.result += A
-    def ccl(self,A,phiA,phiB,Radius,lenTC1,lenTC2,tranfunc):
+    def generate_add(self,A,phiA,phiB,Radius,lenTC1,lenTC2,tranfunc,R0=0):
+        delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
+        
+        if(lenTC1>0):
+            tc1_tmp = self.curvegen.transition_curve(lenTC1,\
+                                          R0,\
+                                          Radius,\
+                                          0,\
+                                          tranfunc,n=10) # 入口側の緩和曲線
+        else:
+            tc1_tmp=(np.array([[0,0]]),0,0)
+            
+        if(lenTC2>0):
+            tc2_tmp = self.curvegen.transition_curve(lenTC2,\
+                                          Radius,\
+                                          0,\
+                                          0,\
+                                          tranfunc,n=10) # 出口側の緩和曲線
+        else:
+            tc2_tmp=(np.array([[0,0]]),0,0)
+
+        phi_circular = delta_phi - tc1_tmp[1] - tc2_tmp[1] # 円軌道での方位角変化
+        
+        cc_tmp = self.curvegen.circular_curve(Radius*phi_circular,\
+                                   Radius,\
+                                   tc1_tmp[1]) # 円軌道
+
+        phi_tc2 = tc1_tmp[1] + cc_tmp[1] # 出口側緩和曲線始端の方位角
+        
+        result_tmp = np.vstack((np.array([0,0]),tc1_tmp[0]))
+        result_tmp = np.vstack((result_tmp,result_tmp[-1] + cc_tmp[0]))
+        result_tmp = np.vstack((result_tmp,result_tmp[-1] + np.dot(self.curvegen.rotate(phi_tc2), tc2_tmp[0].T).T))
+        
+        result_tmp = np.dot(self.curvegen.rotate(phiA), result_tmp.T).T
+        result_tmp += A
+
+        self.result = np.vstack((self.result,result_tmp))
+    def ccl(self,A,phiA,phiB,Radius,lenTC1,lenTC2,tranfunc,R0=0):
         ''' 円軌道の長さ(CCL), 円軌道での方位角変化を求める
         '''
         delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
         
         if(lenTC1>0):
             tc1_tmp = self.curvegen.transition_curve(lenTC1,\
-                                          0,\
+                                          R0,\
                                           Radius,\
                                           0,\
                                           tranfunc) # 入口側の緩和曲線
         else:
             tc1_tmp=(np.array([[0,0]]),0,0)
             
         if(lenTC2>0):
@@ -83,17 +120,17 @@
                                           0,\
                                           tranfunc) # 出口側の緩和曲線
         else:
             tc2_tmp=(np.array([[0,0]]),0,0)
 
         phi_circul = delta_phi - tc1_tmp[1] - tc2_tmp[1] # 円軌道での方位角変化
         return (Radius*phi_circul, phi_circul)
-    def phi_TC(self,lenTC1, Radius, tranfunc):
+    def phi_TC(self,lenTC1, Radius, tranfunc, R0=0):
         if lenTC1>0:
             tc1_tmp = self.curvegen.transition_curve(lenTC1,\
-                                              0,\
+                                              R0,\
                                               Radius,\
                                               0,\
                                               tranfunc) # 入口側の緩和曲線
         else:
             tc1_tmp=(np.array([[0,0]]),0,0)    
         return tc1_tmp[1]
```

## tsutsuji/math.py

```diff
@@ -115,14 +115,16 @@
          ndarray
             track: np.array([[x0,y0],[x1,y1],...,[xn,yn]])
 
     Return:
     '''
     return None
 def angle_twov(phiA, phiB):
+    ''' ベクトルA (方位角phiA)からベクトルB(方位角phiB)への方位角変化を求める
+    '''
     eA = np.array([np.cos(phiA),np.sin(phiA)])
     eB = np.array([np.cos(phiB),np.sin(phiB)])
     return np.arccos(np.dot(eA,eB))*np.sign(np.cross(eA,eB))
 
 def interpolate_with_dist(track, element, cp_dist):
     def interpolate(data,ix,typ,cp_dist,base=0):
         return (data[:,typ][ix+1]-data[:,typ][ix])/(data[:,base][ix+1]-data[:,base][ix])*(cp_dist-data[:,base][ix])+data[:,typ][ix]
```

## tsutsuji/measure.py

```diff
@@ -232,43 +232,56 @@
             
             self.curvetrack_value_f = ttk.Frame(self.curvetrack_f, padding='3 3 3 3')
             self.curvetrack_value_f.grid(column=0, row=1, sticky=(tk.N, tk.W, tk.E, tk.S))
             self.curvetrack_l = {}
             self.curvetrack_e = {}
             self.curvetrack_v = {}
             pos = 0
-            for i in ['TCL α','TCL β','CCL', 'R']:
+            row = 0
+            for i in ['TCL α','TCL β','CCL', 'R', 'TCL γ', 'TCL δ', 'L int.', 'R2']:
                 self.curvetrack_l[i] = ttk.Label(self.curvetrack_value_f, text=i)
-                self.curvetrack_l[i].grid(column=pos, row=0, sticky=(tk.E,tk.W))
+                self.curvetrack_l[i].grid(column=pos, row=row*2, sticky=(tk.E,tk.W))
 
                 self.curvetrack_v[i] = tk.DoubleVar(value=0)
                 self.curvetrack_e[i] = ttk.Entry(self.curvetrack_value_f, textvariable=self.curvetrack_v[i],width=8)
-                self.curvetrack_e[i].grid(column=pos, row=1, sticky=(tk.E,tk.W))
+                self.curvetrack_e[i].grid(column=pos, row=row*2+1, sticky=(tk.E,tk.W))
                 pos+=1
+                if pos%4 == 0:
+                    pos = 0
+                    row += 1
             self.curve_transfunc_v = tk.StringVar(value='line')
             
             self.curve_transfunc_f = ttk.Frame(self.curvetrack_f, padding='3 3 3 3')
             self.curve_transfunc_f.grid(column=3, row=1, sticky=(tk.N, tk.W, tk.E, tk.S))
             self.curve_transfunc_line_b = ttk.Radiobutton(self.curve_transfunc_f, text='line', variable=self.curve_transfunc_v, value='line')
             self.curve_transfunc_line_b.grid(column=0, row=0, sticky=(tk.E,tk.W))
             self.curve_transfunc_sin_b = ttk.Radiobutton(self.curve_transfunc_f, text='sin', variable=self.curve_transfunc_v, value='sin')
             self.curve_transfunc_sin_b.grid(column=0, row=2, sticky=(tk.E,tk.W))
 
             self.curve_fitmode_l = ttk.Label(self.curve_transfunc_f, text='Mode')
             self.curve_fitmode_l.grid(column=1, row=0, sticky=(tk.E))
-            self.curve_fitmode_v = tk.StringVar(value='1. α(fix)->β(free), R(free)')
-            self.curve_fitmode_box = ttk.Combobox(self.curve_transfunc_f,textvariable=self.curve_fitmode_v)
+            curve_fitmode_tuple  = ('1. α(fix)->β(free), R(free)',\
+                                    '2. α(free)->β(fix), R(free)',\
+                                    '3-1. α(free)->β(free), R(fix)',\
+                                    '3-2. α->γ->β, (fixed R,R2)',\
+                                    '4. α(fix), R(fix), CCL(fix)',\
+                                    '5. β(fix), R(fix), CCL(fix)',\
+                                    '6. α(fix)->β(free) via γ, R(free)',\
+                                    '7. α(free)->β(fix) via γ, R(free)',\
+                                    '8-1. Reverse α->β',\
+                                    '8-2. Reverse α->γ->β',\
+                                    #'8-3. Reverse α->β (fixed R)',\
+                                    #'8-4. Reverse α->β (fixed R,R2)',\
+                                    '9-1. Compound α->γ->β',\
+                                    '9-2. Compound α->β (fixed R)',\
+                                    '9-3. Compound α->β (fixed R,R2)')
+            self.curve_fitmode_v = tk.StringVar(value=curve_fitmode_tuple[0])
+            self.curve_fitmode_box = ttk.Combobox(self.curve_transfunc_f,textvariable=self.curve_fitmode_v,height=len(curve_fitmode_tuple),width=28)
             self.curve_fitmode_box.grid(column=2, row=0, sticky=(tk.E,tk.W))
-            self.curve_fitmode_box['values'] = ('1. α(fix)->β(free), R(free)',\
-                                                '2. α(free)->β(fix), R(free)',\
-                                                '3. α(free)->β(free), R(fix)',\
-                                                '4. α(fix), R(fix), CCL(fix)',\
-                                                '5. β(fix), R(fix), CCL(fix)',\
-                                                '6. α(fix)->β(free) via γ, R(free)',\
-                                                '7. α(free)->β(fix) via γ, R(free)')
+            self.curve_fitmode_box['values'] = curve_fitmode_tuple
             self.curve_fitmode_box.state(["readonly"])
             
             self.calc_b = ttk.Button(self.curve_transfunc_f, text="Do It", command=self.ctfit)
             self.calc_b.grid(column=2, row=2, sticky=(tk.E,tk.W))
 
             self.calc_mapsyntax_v = tk.BooleanVar(value=True)
             self.calc_mapsyntax_b = ttk.Checkbutton(self.curve_transfunc_f, text='mapsyntax',variable=self.calc_mapsyntax_v,onvalue=True,offvalue=False)
@@ -334,238 +347,95 @@
         cursor_f_name = self.curvetrack_cursor['v']['α'].get()
         cursor_t_name = self.curvetrack_cursor['v']['β'].get()
         cursor_via_name = self.curvetrack_cursor['v']['γ'].get()
         cursor_f = cursor_obj[cursor_f_name]
         cursor_t = cursor_obj[cursor_t_name]
         cursor_via = cursor_obj[cursor_via_name]
         
-        sv = solver.solver()
         A = np.array([cursor_f.values[0].get(),cursor_f.values[1].get()])
         B = np.array([cursor_t.values[0].get(),cursor_t.values[1].get()])
+        C = np.array([cursor_via.values[0].get(),cursor_via.values[1].get()])
         phiA = np.deg2rad(cursor_f.values[2].get())
         phiB = np.deg2rad(cursor_t.values[2].get())
+        phiC = np.deg2rad(cursor_via.values[2].get())
         lenTC1 = self.curvetrack_v['TCL α'].get()
         lenTC2 = self.curvetrack_v['TCL β'].get()
+        lenTC3 = self.curvetrack_v['TCL γ'].get()
+        lenTC4 = self.curvetrack_v['TCL δ'].get()
         lenCC = self.curvetrack_v['CCL'].get()
+        lenLint = self.curvetrack_v['L int.'].get()
         R_input = self.curvetrack_v['R'].get()
+        R2_input = self.curvetrack_v['R2'].get()
         tranfunc = self.curve_transfunc_v.get()
 
         fitmode = self.curve_fitmode_v.get()
 
+        sv = solver.solver()
+        ax = self.mainwindow.ax_plane
         trackp = curvetrackplot.trackplot()
-        if fitmode == self.curve_fitmode_box['values'][0]: #'1. α(fix)->β(free), R(free)'
-            result = sv.curvetrack_fit(A,phiA,B,phiB,lenTC1,lenTC2,tranfunc)
-            trackp.generate(A,phiA,phiB,result[0],lenTC1,lenTC2,tranfunc)
-            R_result = result[0]
-            CCL_result = trackp.ccl(A,phiA,phiB,result[0],lenTC1,lenTC2,tranfunc)[0]
-            shift_result = np.linalg.norm(result[1][0] - B)*np.sign(np.dot(np.array([np.cos(phiB),np.sin(phiB)]),result[1][0] - B))
-        elif fitmode == self.curve_fitmode_box['values'][1]: #'2. α(free)->β(fix), R(free)'
-            if False:
-                import pdb
-                pdb.set_trace()
-            phiA_inv = phiA - np.pi if phiA>0 else phiA + np.pi
-            phiB_inv = phiB - np.pi if phiB>0 else phiB + np.pi
-            result = sv.curvetrack_fit(B,phiB_inv,A,phiA_inv,lenTC2,lenTC1,tranfunc)
-            trackp.generate(B,phiB_inv,phiA_inv,result[0],lenTC2,lenTC1,tranfunc)
-            R_result = -result[0]
-            CCL_result = trackp.ccl(B,phiB_inv,phiA_inv,result[0],lenTC1,lenTC2,tranfunc)[0]
-            shift_result = np.linalg.norm(result[1][0] - A)*np.sign(np.dot(np.array([np.cos(phiA),np.sin(phiA)]),result[1][0] - A))
-        elif fitmode == self.curve_fitmode_box['values'][2]: #'3. α(free)->β(free), R(fix)'
-            if False:
-                import pdb
-                pdb.set_trace()
-            result = sv.curvetrack_relocation(A,phiA,B,phiB,lenTC1,lenTC2,tranfunc,R_input)
-            A_result = A + np.array([np.cos(phiA),np.sin(phiA)])*result[0]
-            R_result = R_input
-            trackp.generate(A_result,phiA,phiB,R_input,lenTC1,lenTC2,tranfunc)
-            CCL_result = trackp.ccl(A_result,phiA,phiB,R_input,lenTC1,lenTC2,tranfunc)[0]
-            shift_result = result[0]
-            #print('  x = {:f}'.format(result[0]))
-        elif fitmode == self.curve_fitmode_box['values'][3]: #'4. α(fix), R(fix), CCL(fix)'
-            phi_end = phiA + lenCC/R_input + trackp.phi_TC(lenTC1, R_input, tranfunc) + trackp.phi_TC(lenTC2, R_input, tranfunc)
-            trackp.generate(A, phiA, phi_end, R_input, lenTC1, lenTC2, tranfunc)
-            R_result = R_input
-            CCL_result = lenCC
-            shift_result = 0
-        elif fitmode == self.curve_fitmode_box['values'][4]: #'5. β(fix), R(fix), CCL(fix)'
-            phi_end = phiB - (lenCC/R_input + trackp.phi_TC(lenTC1, R_input, tranfunc) + trackp.phi_TC(lenTC2, R_input, tranfunc))
-            trackp.generate(B, phiB + np.pi if phiB>0 else phiB - np.pi, phi_end + np.pi if phi_end>0 else phi_end - np.pi, -R_input, lenTC2, lenTC1, tranfunc)
-            R_result = R_input
-            CCL_result = lenCC
-            shift_result = 0
-        elif fitmode == self.curve_fitmode_box['values'][5]: #'6. α(fix)->β(free) via γ, R(free)'
-            if False:
-                import pdb
-                pdb.set_trace()
-            C = np.array([cursor_via.values[0].get(),cursor_via.values[1].get()])
-            result = sv.shift_by_TCL(A,phiA,B,phiB,C,tranfunc)
-            trackp.generate(A,phiA,phiB,result[1][2],result[0],result[0],tranfunc)
-            R_result = result[1][2]
-            CCL_result = result[1][1]
-            TCL_result = result[0]
-            endpoint = trackp.result[-1]
-            shift_result = np.linalg.norm(endpoint - B)*np.sign(np.dot(np.array([np.cos(phiB),np.sin(phiB)]),endpoint - B))
-            #print(R_result, CCL_result, TCL_result)
-            #print('transCL: {:f}, mindist: {:f}, CCL: {:f}, Rtmp: {:f}, num: {:f}'.format(result[0],result[1][0],result[1][1],result[1][2],result[2]))
-        elif fitmode == self.curve_fitmode_box['values'][6]: #'7. α(free)->β(fix) via γ, R(free)'
-            if False:
-                import pdb
-                pdb.set_trace()
-            phiA_inv = phiA - np.pi if phiA>0 else phiA + np.pi
-            phiB_inv = phiB - np.pi if phiB>0 else phiB + np.pi
-            C = np.array([cursor_via.values[0].get(),cursor_via.values[1].get()])
-            result = sv.shift_by_TCL(B,phiB_inv,A,phiA_inv,C,tranfunc)
-            trackp.generate(B,phiB_inv,phiA_inv,result[1][2],result[0],result[0],tranfunc)
-            R_result = -result[1][2]
-            CCL_result = result[1][1]
-            TCL_result = result[0]
-            endpoint = trackp.result[-1]
-            shift_result = np.linalg.norm(endpoint - A)*np.sign(np.dot(np.array([np.cos(phiA),np.sin(phiA)]),endpoint - A))
+        svIF = solver.IF(A,\
+                         B,\
+                         C,\
+                         phiA,\
+                         phiB,\
+                         phiC,\
+                         lenTC1,\
+                         lenTC2,\
+                         lenTC3,\
+                         lenTC4,\
+                         lenCC,\
+                         lenLint,\
+                         R_input,\
+                         R2_input,\
+                         tranfunc,\
+                         fitmode,\
+                         self.curve_fitmode_box,\
+                         cursor_obj,\
+                         cursor_f_name,\
+                         cursor_t_name,\
+                         cursor_via_name)
+
+        if   fitmode.startswith('1.'): #'1. α(fix)->β(free), R(free)'
+            result = svIF.mode1()
+        elif fitmode.startswith('2.'): #'2. α(free)->β(fix), R(free)'
+            result = svIF.mode2()
+        elif fitmode.startswith('3-1.'): #'3-1. α(free)->β(free), R(fix)'
+            result = svIF.mode3()
+        elif fitmode.startswith('3-2.'):
+            result = svIF.mode10()
+        elif fitmode.startswith('4.'): #'4. α(fix), R(fix), CCL(fix)'
+            result = svIF.mode4_5(self.curvetrack_cursor_assignresult_v.get())
+        elif fitmode.startswith('5.'): #'5. β(fix), R(fix), CCL(fix)'
+            result = svIF.mode4_5(self.curvetrack_cursor_assignresult_v.get())
+        elif fitmode.startswith('6.'): #'6. α(fix)->β(free) via γ, R(free)'
+            result = svIF.mode6()
+        elif fitmode.startswith('7.'): #'7. α(free)->β(fix) via γ, R(free)'
+            result = svIF.mode7()
+        elif fitmode.startswith('8-1.'):
+            result = svIF.mode8(withCpos=False)
+        elif fitmode.startswith('8-2.'):
+            result = svIF.mode8()
+        #elif fitmode.startswith('8-3.'):
+        #    result = svIF.mode12()
+        #elif fitmode.startswith('8-4.'):
+        #    result = svIF.mode13()
+        elif fitmode.startswith('9-1.'):
+            result = svIF.mode9()
+        elif fitmode.startswith('9-2.'):
+            #result = svIF.mode9(givenR1=True)
+            result = svIF.mode9_12(givenR1=True)
+        elif fitmode.startswith('9-3.'):
+            result = svIF.mode11_13()
         else:
             raise Exception('invalid fitmode')
-
-        # パラメータ、計算結果の印字
-        if fitmode == self.curve_fitmode_box['values'][0] or fitmode == self.curve_fitmode_box['values'][1]: #'1 or 2'
-            print()
-            print('[Curve fitting]')
-            print('Inputs:')
-            print('   Fitmode:          {:s}'.format(fitmode))
-            print('   Cursor α,β:       {:s},{:s}'.format(cursor_f_name,cursor_t_name))
-            print('   Ponint α:         ({:f}, {:f})'.format(A[0],A[1]))
-            print('   Ponint β:         ({:f}, {:f})'.format(B[0],B[1]))
-            print('   Direction α:     {:f}'.format(cursor_f.values[2].get()))
-            print('   Direction β:     {:f}'.format(cursor_t.values[2].get()))
-            print('   Transition func.: {:s}'.format(tranfunc))
-            print('   TCL α:            {:f}'.format(lenTC1))
-            print('   TCL β:            {:f}'.format(lenTC2))            
-            print('Results:')
-            print('   R:   {:f}'.format(R_result))
-            print('   CCL: {:f}'.format(CCL_result))
-            if fitmode == self.curve_fitmode_box['values'][0]:
-                print('   endpt:            ({:f}, {:f})'.format(result[1][0][0],result[1][0][1]))
-                print('   shift from pt. β: {:f}'.format(shift_result))
-            else:
-                print('   startpt:          ({:f}, {:f})'.format(result[1][0][0],result[1][0][1]))
-                print('   shift from pt. α: {:f}'.format(shift_result))
-        elif fitmode == self.curve_fitmode_box['values'][2]: # 3
-            print()
-            print('[Curve fitting]')
-            print('Inputs:')
-            print('   Fitmode:          {:s}'.format(fitmode))
-            print('   Cursor α,β:       {:s},{:s}'.format(cursor_f_name,cursor_t_name))
-            print('   Ponint α:         ({:f}, {:f})'.format(A[0],A[1]))
-            print('   Ponint β:         ({:f}, {:f})'.format(B[0],B[1]))
-            print('   Direction α:     {:f}'.format(cursor_f.values[2].get()))
-            print('   Direction β:     {:f}'.format(cursor_t.values[2].get()))
-            print('   Transition func.: {:s}'.format(tranfunc))
-            print('   TCL α:            {:f}'.format(lenTC1))
-            print('   TCL β:            {:f}'.format(lenTC2))
-            print('   R:                {:f}'.format(R_input))
-            print('Results:')
-            print('   CCL:        {:f}'.format(CCL_result))
-            print('   startpoint: ({:f}, {:f})'.format(A_result[0],A_result[1]))
-            print('   shift:      {:f}'.format(shift_result))
-        elif fitmode == self.curve_fitmode_box['values'][3] or fitmode == self.curve_fitmode_box['values'][4]: #4, 5
-            cursor_label = 'α' if fitmode == self.curve_fitmode_box['values'][3] else 'β'
-            print()
-            print('[Curve fitting]')
-            print('Inputs:')
-            print('   Fitmode:          {:s}'.format(fitmode))
-            print('   Cursor {:s}:         {:s}'.format(cursor_label,cursor_f_name))
-            print('   Ponint {:s}:         ({:f}, {:f})'.format(cursor_label,A[0],A[1]))
-            print('   Direction {:s}:      {:f}'.format(cursor_label,cursor_f.values[2].get()))
-            print('   Transition func.: {:s}'.format(tranfunc))
-            print('   TCL α:            {:f}'.format(lenTC1))
-            print('   TCL β:            {:f}'.format(lenTC2))
-            print('   CCL:              {:f}'.format(CCL_result))
-            print('   R:                {:f}'.format(R_input))
-            print('Results:')
-            if fitmode == self.curve_fitmode_box['values'][3]:
-                print('   endpoint: ({:f}, {:f})'.format(trackp.result[:,0][-1],trackp.result[:,1][-1]))
-                print('   phi_end:  {:f}'.format(np.rad2deg(phi_end)))
-                
-            else:
-                print('   startpoint: ({:f}, {:f})'.format(trackp.result[:,0][-1],trackp.result[:,1][-1]))
-                print('   phi_start:  {:f}'.format(np.rad2deg(phi_end)))
-        elif fitmode == self.curve_fitmode_box['values'][5] or fitmode == self.curve_fitmode_box['values'][6]: #'6'
-            print()
-            print('[Curve fitting]')
-            print('Inputs:')
-            print('   Fitmode:          {:s}'.format(fitmode))
-            print('   Cursor α,β,γ:     {:s},{:s},{:s}'.format(cursor_f_name,cursor_t_name,cursor_via_name))
-            print('   Ponint α:         ({:f}, {:f})'.format(A[0],A[1]))
-            print('   Ponint β:         ({:f}, {:f})'.format(B[0],B[1]))
-            print('   Ponint γ:         ({:f}, {:f})'.format(C[0],C[1]))
-            print('   Direction α:     {:f}'.format(cursor_f.values[2].get()))
-            print('   Direction β:     {:f}'.format(cursor_t.values[2].get()))
-            print('   Transition func.: {:s}'.format(tranfunc))          
-            print('Results:')
-            print('   R:   {:f}'.format(R_result))
-            print('   CCL: {:f}'.format(CCL_result))
-            print('   TCL: {:f}'.format(TCL_result))
-            if fitmode == self.curve_fitmode_box['values'][5]:
-                endpoint = trackp.result[-1]
-                print('   endpt:            ({:f}, {:f})'.format(endpoint[0],endpoint[1]))
-                print('   shift from pt. β: {:f}'.format(shift_result))
-            else:
-                print('   startpt:          ({:f}, {:f})'.format(endpoint[0],endpoint[1]))
-                print('   shift from pt. α: {:f}'.format(shift_result))
-
-        # 演算結果をカーソルに設定 (mode4, 5のみ)
-        if self.curvetrack_cursor_assignresult_v.get():
-            if fitmode == self.curve_fitmode_box['values'][3]:
-                tmp_cursor = cursor_t
-                tmp_cursor.values[0].set(trackp.result[:,0][-1])
-                tmp_cursor.values[1].set(trackp.result[:,1][-1])
-                tmp_cursor.values[2].set(np.rad2deg(phi_end))
-                tmp_cursor.marker.set_direct()
-                tmp_cursor.arrow.set_direct()
-            elif fitmode == self.curve_fitmode_box['values'][4]:
-                tmp_cursor = cursor_f
-                tmp_cursor.values[0].set(trackp.result[:,0][-1])
-                tmp_cursor.values[1].set(trackp.result[:,1][-1])
-                tmp_cursor.values[2].set(np.rad2deg(phi_end))
-                tmp_cursor.marker.set_direct()
-                tmp_cursor.arrow.set_direct()
-        # 自軌道構文の印字
-        if self.calc_mapsyntax_v.get():
-            print()
-            
-            print('$pt_a = {:f};'.format(cursor_f.values[4].get() if cursor_f.values[3].get() != '@absolute' else 0))
-            if fitmode == self.curve_fitmode_box['values'][0] or fitmode == self.curve_fitmode_box['values'][5]:
-                shift = 0
-                print('$pt_a;')
-            else:
-                shift = shift_result
-                print('$pt_a {:s}{:f};'.format('+' if shift>=0 else '',shift))
-            print('$cant = 0;')
-            print('Curve.SetFunction({:d});'.format(0 if tranfunc == 'sin' else 1))
-            print('Curve.Interpolate({:f},0);'.format(0))
-            if fitmode == self.curve_fitmode_box['values'][5] or fitmode == self.curve_fitmode_box['values'][6]:
-                lenTC_result = {'1':TCL_result, '2':TCL_result}
-            else:
-                lenTC_result = {'1':lenTC1, '2':lenTC2}
-            if lenTC_result['1'] != 0 or True:
-                tmp = shift + lenTC_result['1']
-                print('$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp))
-            print('Curve.Interpolate({:f}, $cant);'.format(R_result))
-            tmp = (shift + lenTC_result['1'] + CCL_result)
-            print('$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp))
-            print('Curve.Interpolate({:f}, $cant);'.format(R_result))
-            if lenTC_result['2'] != 0 or True:
-                tmp = (shift + lenTC_result['1'] + CCL_result + lenTC_result['2'])
-                print('$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp))
-            print('Curve.Interpolate({:f},0);'.format(0))
-            
-        ax = self.mainwindow.ax_plane
-        ax.plot(trackp.result[:,0],trackp.result[:,1])
-        '''
-        if not __debug__:
-            ax.scatter(result[1][0][0],result[1][0][1])
-        '''
+        
+        print()
+        print(result['param'])
+        print(result['syntax'])
+        ax.plot(result['track'][:,0],result['track'][:,1])
         self.mainwindow.fig_canvas.draw()
     def nearesttrack(self):
         '''指定した軌道上のカーソルAに最も近い点を求める
         '''
         cursor = self.nearesttrack_cursor_v.get()
         cursor_obj = {'A':self.cursor_A, 'B':self.cursor_B, 'C':self.cursor_C, 'D':self.cursor_D}
```

## tsutsuji/solver.py

```diff
@@ -1,9 +1,9 @@
 #
-#    Copyright 2021-2022 konawasabi
+#    Copyright 2021-2023 konawasabi
 #
 #    Licensed under the Apache License, Version 2.0 (the "License");
 #    you may not use this file except in compliance with the License.
 #    You may obtain a copy of the License at
 #
 #        http://www.apache.org/licenses/LICENSE-2.0
 #
@@ -22,20 +22,20 @@
 from . import math
 from . import curvetrackplot
 
 class solver():
     def __init__(self):
         self.ci = tc.curve_intermediate()
         self.cgen = tc.curve()
-    def temporal_trackparam(self,Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,tranfunc):
+    def temporal_trackparam(self,Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,tranfunc,R0=0):
         delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
             
         if(lenTC1>0):
             tc1_tmp = self.ci.transition_curve(lenTC1,\
-                                          0,\
+                                          R0,\
                                           Rtmp,\
                                           phiA,\
                                           tranfunc,\
                                           lenTC1) # 入口側の緩和曲線
         else:
             tc1_tmp=(np.array([0,0]),0,0)
 
@@ -81,60 +81,62 @@
 
             # 点Bを通る直線の一般形 ax+by+c=0
             a = -np.tan(phiB)
             b = 1
             c = - a*B[0] - B[1]
             residual = np.abs(a*res_tmp[0]+b*res_tmp[1]+c)/np.sqrt(a**2+b**2) # 点res_tmpと点Bを通る直線の距離
 
-            return (res_tmp,residual)
+            return (res_tmp,residual,phi_circular,phi_tc2)
         
         # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線始点をニュートン法で求める
         num=0 # 繰り返し回数
         f1 = (np.array([0,0]),error*100)
         x =0
-        while (f1[1] > error and num<1e3):
+        while (f1[1] > error and num<1e2):
             f1 = func_TC(R,lenTC1,lenTC2,A,B,phiA,phiB,x)
             df = (func_TC(R,lenTC1,lenTC2,A,B,phiA,phiB,x+dx)[1]-func_TC(R,lenTC1,lenTC2,A,B,phiA,phiB,x)[1])/dx
 
             x = x - f1[1]/df
             num +=1
         return (x,f1,num)
-    def curvetrack_fit (self,A,phiA,B,phiB,lenTC1,lenTC2,tranfunc,Rtmp=1000,dr=0.1,error=0.01):
+    def curvetrack_fit (self,A,phiA,B,phiB,lenTC1,lenTC2,tranfunc,Rtmp=1000,dr=0.1,error=0.01,R0=0):
         ''' AB間を結ぶ曲線軌道の半径を返す
         A:        始点座標
         phiA:     始点での軌道方位
         B:        終点座標
         phiB:     終点での軌道方位
         lenTC1:   始点側の緩和曲線長さ
         lenTC2:   終点側の緩和曲線長さ
         tranfunc: 逓減関数 'line' or 'sin'
         Rtmp:     曲線半径初期値
         dr:       残差の微分で使う
         error:    許容誤差
+
+        R0:       始点での軌道半径（複合曲線の緩和曲線を求める際に使用, default: 0）
         '''
 
-        def func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB):
-            tc1_tmp, tc2_tmp, cc_tmp, phi_circular, phi_tc2 = self.temporal_trackparam(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,tranfunc)
+        def func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,R0):
+            tc1_tmp, tc2_tmp, cc_tmp, phi_circular, phi_tc2 = self.temporal_trackparam(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,tranfunc,R0=R0)
 
             res_tmp = A + tc1_tmp[0] + cc_tmp[0] + np.dot(self.ci.rotate(phi_tc2),tc2_tmp[0]) # 与えられたR, lenTC, delta_phiから計算した着点座標
 
             # 点Bを通る直線の一般形 ax+by+c=0
             a = -np.tan(phiB)
             b = 1
             c = - a*B[0] - B[1]
             residual = np.abs(a*res_tmp[0]+b*res_tmp[1]+c)/np.sqrt(a**2+b**2) # 点res_tmpと点Bを通る直線の距離
 
-            return (res_tmp,residual)
+            return (res_tmp,residual,phi_circular,phi_tc2)
         
         # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線半径をニュートン法で求める
         num=0 # 繰り返し回数
         f1 = (np.array([0,0]),error*100)
-        while (f1[1] > error and num<1e3):
-            f1 = func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB)
-            df = (func_TC(Rtmp+dr,lenTC1,lenTC2,A,B,phiA,phiB)[1]-func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB)[1])/dr
+        while (f1[1] > error and num<1e2):
+            f1 = func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,R0)
+            df = (func_TC(Rtmp+dr,lenTC1,lenTC2,A,B,phiA,phiB,R0)[1]-func_TC(Rtmp,lenTC1,lenTC2,A,B,phiA,phiB,R0)[1])/dr
 
             Rtmp = Rtmp - f1[1]/df
             num +=1
         return (Rtmp,f1,num)
     def shift_by_TCL(self,A,phiA,B,phiB,C,tranfunc,TCLtmp=0,dl=0.1,error=0.001):
         ''' AB間を結び、Cに最も近い点を通過する曲線軌道の半径、TCL, CCLを返す。
         始点: A、終点: Bの延長線上となる曲線軌道について、点Cとの距離が最小となるR, TCLをニュートン法で求める。
@@ -187,7 +189,1151 @@
                f1 = func(transCL,A,B,phiA,phiB,C,tranfunc)
                df = (func(transCL+dl,A,B,phiA,phiB,C,tranfunc)[1]-func(transCL,A,B,phiA,phiB,C,tranfunc)[1])/dl
 
                transCL = transCL - f1[1]/df
                num +=1
             
         return (transCL,f1,num)
+    def reverse_curve(self,A,phiA,B,phiB,lenTC11,lenTC12,lenTC21,lenTC22,tranfunc,len_interm=0,C=None,R1=None,R2=None,lenCC1=None,lenCC2=None):
+        '''
+        [A]-TC-CC-TC-[C]-S-TC-CC-TC-[B]
+        '''
+        if C is None:
+            C = (A + B)/2
+
+        phiC_tmp = np.arccos(np.dot(C-A,np.array([np.cos(phiA),np.sin(phiA)]))/(np.linalg.norm(C-A)))
+        phiC = np.sign(-np.cross(C-A,np.array([np.cos(phiA),np.sin(phiA)])))*np.arccos((1-np.tan(phiC_tmp)**2)/(1+np.tan(phiC_tmp)**2)) + phiA
+        
+        result_1st = self.curvetrack_fit(A, phiA, C, phiC, lenTC11, lenTC12, tranfunc)
+        Cdash = result_1st[1][0] + np.array([np.cos(phiC),np.sin(phiC)])*len_interm
+
+        result_2nd = self.curvetrack_fit(Cdash, phiC, B, phiB, lenTC21, lenTC22, tranfunc)
+        return (result_1st,result_2nd,C,Cdash,phiC)
+    def compound_curve(self,A,phiA,B,phiB,C,phiC,lenTC1,lenTC2,lenTC3,tranfunc,dl=0.1,error=0.01,num_max=50,givenR1=None):
+        '''
+        [A]-TC-CC-[C]-CC-TC-CC-TC-[B]
+        based on mode1
+        '''
+        def func(R1,CCL1tmp,A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc):
+            # [A]-TC1-CC1-TC2-CC2-TC3-[B]なる複合曲線において、CC1の長さをCCL1tmpで与えた場合の着点座標を求める
+            # CC1終点座標,方位を求める
+            if(lenTC1>0):
+                tc1_tmp = self.ci.transition_curve(lenTC1,\
+                                              0,\
+                                              R1,\
+                                              phiA,\
+                                              tranfunc,\
+                                              lenTC1) # 入口側の緩和曲線
+            else:
+                tc1_tmp=(np.array([0,0]),0,0)
+            cc_tmp = self.ci.circular_curve(CCL1tmp,\
+                                            R1,\
+                                            tc1_tmp[1]+phiA,\
+                                            CCL1tmp) # 円軌道
+
+            CC1end = [A + tc1_tmp[0] + cc_tmp[0], phiA + tc1_tmp[1] + cc_tmp[1]]
+
+            '''
+            # 求めた曲線CC1と点Cの最短距離を求める
+            cc_tmp_array = self.cgen.circular_curve(CCL1tmp,\
+                                                    R1,\
+                                                    tc1_tmp[1]+phiA,\
+                                                    n=20)[0] # 円軌道
+            cc_tmp_array += A + tc1_tmp[0]
+            residual = (min(np.linalg.norm(cc_tmp_array-C,axis=1)))
+            '''
+
+            # CC1endを始点、Bの延長線上を終点とする単円軌道を求める
+            TC3end = self.curvetrack_fit(CC1end[0], CC1end[1], B, phiB, lenTC2, lenTC3, tranfunc, R0=R1)
+
+            # 点TC3endと点Bの距離
+            residual = (np.linalg.norm(TC3end[1][0]-B))
+            
+            return (residual, CC1end, TC3end)
+
+        # 点Aを始点、点Cの延長線上を通過する単円軌道の半径を求める
+        if givenR1 is None:
+            result_R1 = self.curvetrack_fit(A, phiA, C, phiC, lenTC1, 0, tranfunc)
+        else:
+            result_R1 = [givenR1]
+
+        # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線長CCL1をニュートン法で求める
+        num=0 # 繰り返し回数
+        f1 = (error*100,None,None)
+        CCL1 = 100
+        while (f1[0] > error and num < num_max):
+            f1 =  func(result_R1[0],CCL1,   A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)
+            df = (func(result_R1[0],CCL1+dl,A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)[0]\
+                 -func(result_R1[0],CCL1,   A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)[0])/dl
+
+            CCL1 = CCL1 - f1[0]/df
+            num +=1
+            if CCL1 < 0 or f1[2][1][2]*f1[2][0] < 0: # CCL1<0 or phiCC2*R2(=CCL2)<0
+                raise Exception('invalid parameters')
+
+        '''returns: 
+           CCL1
+           f1
+              residual
+              CC1end
+              TC3end
+           num
+           result_r1
+        '''
+        return (CCL1,f1,num,result_R1)
+    def compound_curve_shiftStartPos(self,A,phiA,B,phiB,C,phiC,lenTC1,lenTC2,lenTC3,tranfunc,dl=0.1,error=0.01,num_max=50,givenR1=None):
+        '''
+        [A]-TC-CC-[C]-CC-TC-CC-TC-[B]
+        based on mode2
+        '''
+        def func(R1,CCL1tmp,A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc):
+            # [A]-TC1-CC1-TC2-CC2-TC3-[B]なる複合曲線において、CC1の長さをCCL1tmpで与えた場合の着点座標を求める
+            # CC1終点座標,方位を求める
+            if(lenTC1>0):
+                tc1_tmp = self.ci.transition_curve(lenTC1,\
+                                              0,\
+                                              R1,\
+                                              phiA,\
+                                              tranfunc,\
+                                              lenTC1) # 入口側の緩和曲線
+            else:
+                tc1_tmp=(np.array([0,0]),0,0)
+            cc_tmp = self.ci.circular_curve(CCL1tmp,\
+                                            R1,\
+                                            tc1_tmp[1]+phiA,\
+                                            CCL1tmp) # 円軌道
+
+            CC1end = [A + tc1_tmp[0] + cc_tmp[0], phiA + tc1_tmp[1] + cc_tmp[1]]
+
+            '''
+            # 求めた曲線CC1と点Cの最短距離を求める
+            cc_tmp_array = self.cgen.circular_curve(CCL1tmp,\
+                                                    R1,\
+                                                    tc1_tmp[1]+phiA,\
+                                                    n=20)[0] # 円軌道
+            cc_tmp_array += A + tc1_tmp[0]
+            residual = (min(np.linalg.norm(cc_tmp_array-C,axis=1)))
+            '''
+
+            # CC1endを始点、Bの延長線上を終点とする単円軌道を求める
+            TC3end = self.curvetrack_fit(CC1end[0], CC1end[1], B, phiB, lenTC2, lenTC3, tranfunc, R0=R1)
+
+            # 点TC3endと点Bの距離
+            residual = (np.linalg.norm(TC3end[1][0]-B))
+            
+            return (residual, CC1end, TC3end)
+
+        # 点Aの延長線上を始点、点Cを通過する単円軌道の半径を求める
+        if givenR1 is None:
+            phiA_inv = phiA - np.pi if phiA>0 else phiA + np.pi
+            phiC_inv = phiC - np.pi if phiC>0 else phiC + np.pi
+            result_R1_tmp = self.curvetrack_fit(C, phiC_inv, A, phiA_inv, 0, lenTC1, tranfunc)
+            result_R1 = [-result_R1_tmp[0],result_R1_tmp[1],result_R1_tmp[2]]
+            shift_fromA = np.linalg.norm(result_R1[1][0] - A)\
+                * np.sign(np.dot(np.array([np.cos(phiA),np.sin(phiA)]),result_R1[1][0] - A))
+        else:
+            result_R1 = [givenR1,C,0]
+            shift_fromA = 0
+
+        # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線長CCL1をニュートン法で求める
+        num=0 # 繰り返し回数
+        f1 = (error*100,None,None)
+        CCL1 = 100
+        A_shifted = result_R1[1][0]
+        while (f1[0] > error and num < num_max):
+            f1 =  func(result_R1[0],CCL1,   A_shifted,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)
+            df = (func(result_R1[0],CCL1+dl,A_shifted,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)[0]\
+                 -func(result_R1[0],CCL1,   A_shifted,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,tranfunc)[0])/dl
+
+            CCL1 = CCL1 - f1[0]/df
+            num +=1
+
+        '''returns: 
+           CCL1
+           f1
+              residual
+              CC1end
+              TC3end
+           num
+           result_r1
+        '''
+        return (CCL1,f1,num,result_R1,shift_fromA)
+    def compound_curve_Linterm(self,A,phiA,B,phiB,C,phiC,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,tranfunc,dl=0.1,error=0.01,num_max=50,givenR1=None):
+        '''
+        [A]-TC-CC-TC-S-TC-CC-TC-[B]
+        based on mode1
+        '''
+        def func(R1,CCL1tmp,A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,tranfunc):
+            # [A]-TC1-CC1-TC2-S-TC3-CC2-TC4-[B]なる複合曲線において、CC1の長さをCCL1tmpで与えた場合の着点座標を求める
+            # CC1終点座標,方位を求める
+            
+            if(lenTC1>0):
+                tc1_tmp = self.ci.transition_curve(lenTC1,\
+                                                   0,\
+                                                   R1,\
+                                                   phiA,\
+                                                   tranfunc,\
+                                                   lenTC1) # 入口側の緩和曲線
+            else:
+                tc1_tmp=(np.array([0,0]),0,0)
+            cc_tmp = self.ci.circular_curve(CCL1tmp,\
+                                            R1,\
+                                            tc1_tmp[1]+phiA,\
+                                            CCL1tmp) # 円軌道
+            if(lenTC2>0):
+                tc2_tmp = self.ci.transition_curve(lenTC2,\
+                                                   R1,\
+                                                   0,\
+                                                   phiA+tc1_tmp[1]+cc_tmp[1],\
+                                                   tranfunc,\
+                                                   lenTC2) # 入口側の緩和曲線
+            else:
+                tc2_tmp=(np.array([0,0]),0,0)
+            
+
+            CC1end = [A + tc1_tmp[0] + cc_tmp[0] + tc2_tmp[0], phiA + tc1_tmp[1] + cc_tmp[1] + tc2_tmp[1]]
+            CC2start = [CC1end[0] + lenLint * np.array([np.cos(CC1end[1]),np.sin(CC1end[1])]), CC1end[1]]
+            
+            # CC2startを始点、Bの延長線上を終点とする単円軌道を求める
+            TC3end = self.curvetrack_fit(CC2start[0], CC2start[1], B, phiB, lenTC3, lenTC4, tranfunc)
+
+            # 点TC3endと点Bの距離
+            residual = (np.linalg.norm(TC3end[1][0]-B))
+            
+            return (residual, CC1end, TC3end, CC2start)
+
+        # 点Aを始点、点Cの延長線上を通過する単円軌道の半径を求める
+        if givenR1 is None:
+            result_R1 = self.curvetrack_fit(A, phiA, C, phiC, lenTC1, 0, tranfunc)
+        else:
+            result_R1 = [givenR1]
+
+        # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線長CCL1をニュートン法で求める
+        num=0 # 繰り返し回数
+        f1 = (error*100,None,None)
+        CCL1 = 100
+        while (f1[0] > error and num < num_max):
+            f1 =  func(result_R1[0],CCL1,   A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,tranfunc)
+            df = (func(result_R1[0],CCL1+dl,A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,tranfunc)[0]\
+                 -func(result_R1[0],CCL1,   A,phiA,B,phiB,C,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,tranfunc)[0])/dl
+
+            CCL1 = CCL1 - f1[0]/df
+            num +=1
+            if CCL1 < 0 or f1[2][1][2]*f1[2][0] < 0: # CCL1<0 or phiCC2*R2(=CCL2)<0
+                raise Exception('invalid parameters')
+
+        '''returns: 
+           CCL1
+           f1
+              residual
+              CC1end
+              TC3end
+           num
+           result_r1
+        '''
+        return (CCL1,f1,num,result_R1)
+    def compound_curve_givenR(self,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,R1,R2,tranfunc,dphi=0.001,error=0.01,num_max=50):
+        def func(phiCC1,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,R1,R2,tranfunc):
+            #delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
+            
+            if(lenTC1>0):
+                tc1_tmp = self.ci.transition_curve(lenTC1,\
+                                              0,\
+                                              R1,\
+                                              phiA,\
+                                              tranfunc,\
+                                              lenTC1) # 入口側の緩和曲線
+            else:
+                tc1_tmp=(np.array([0,0]),0,0)
+
+            #phi_circular = delta_phi - tc1_tmp[1]-tc2_tmp[1] # 円軌道での方位角変化
+
+            cc1_tmp = self.ci.circular_curve(R1*phiCC1,\
+                                            R1,\
+                                            tc1_tmp[1]+phiA,\
+                                            R1*phiCC1) # 円軌道
+
+            if(lenTC2>0):
+                tc2_tmp = self.ci.transition_curve(lenTC2,\
+                                              R1,\
+                                              R2,\
+                                              cc1_tmp[1]+tc1_tmp[1]+phiA,\
+                                              tranfunc,\
+                                              lenTC2) # 出口側の緩和曲線
+            else:
+                tc2_tmp=(np.array([0,0]),0,0)
+                
+            if(lenTC3>0):
+                tc3_tmp = self.ci.transition_curve(lenTC3,\
+                                                   R2,\
+                                                   0,\
+                                                   0,\
+                                                   tranfunc,\
+                                                   lenTC3) # 出口側の緩和曲線
+            else:
+                tc3_tmp=(np.array([0,0]),0,0)
+
+            #if (math.angle_twov(phiA,phiB) - (tc1_tmp[1] + tc2_tmp[1] + tc3_tmp[1]))<0:
+            #    raise Exception('invalid R1,R2 pair or too long TC1,2,3')
+
+            phiCC2 = math.angle_twov(phiA,phiB) - (tc1_tmp[1] + tc2_tmp[1] + tc3_tmp[1]) - phiCC1
+
+            cc2_tmp = self.ci.circular_curve(R2*phiCC2,\
+                                             R2,\
+                                             tc2_tmp[1]+cc1_tmp[1]+tc1_tmp[1]+phiA,\
+                                             R2*phiCC2) # 円軌道
+
+            res_tmp = A + tc1_tmp[0] + cc1_tmp[0] + tc2_tmp[0] + cc2_tmp[0] + np.dot(self.ci.rotate(phiCC2+tc2_tmp[1]+phiCC1+tc1_tmp[1]+phiA),tc3_tmp[0])
+
+            # 点Bを通る直線の一般形 ax+by+c=0
+            a = -np.tan(phiB)
+            b = 1
+            c = - a*B[0] - B[1]
+            residual = np.abs(a*res_tmp[0]+b*res_tmp[1]+c)/np.sqrt(a**2+b**2) # 点res_tmpと点Bを通る直線の距離
+        
+            return (res_tmp,residual,tc1_tmp,tc2_tmp,tc3_tmp,cc1_tmp,cc2_tmp,phiCC2)
+        # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線始点をニュートン法で求める
+        num=0 # 繰り返し回数
+        f1 = (np.array([0,0]),error*100)
+        phiCC1 = 0.2 if R1>0 else -0.2
+        while (f1[1] > error and num < num_max):
+            f1 = func(phiCC1,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,R1,R2,tranfunc)
+            df =  (func(phiCC1+dphi,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,R1,R2,tranfunc)[1]\
+                  -func(phiCC1,     A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,R1,R2,tranfunc)[1])/dphi
+
+            phiCC1 = phiCC1 - f1[1]/df
+            #if phiCC1 * R1 < 0 or f1[7] * R2 < 0:
+            #    raise Exception('invalid R1,R2 pair')
+            num +=1
+        return (phiCC1,f1,num)
+    def compound_curve_givenR_Lint(self,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,R1,R2,tranfunc,dphi=0.001,error=0.01,num_max=50):
+        def func(phiCC1,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,R1,R2,tranfunc):
+            #delta_phi = math.angle_twov(phiA,phiB) #曲線前後での方位変化
+            
+            if(lenTC1>0):
+                tc1_tmp = self.ci.transition_curve(lenTC1,\
+                                              0,\
+                                              R1,\
+                                              phiA,\
+                                              tranfunc,\
+                                              lenTC1) # 入口側の緩和曲線
+            else:
+                tc1_tmp=(np.array([0,0]),0,0)
+
+            #phi_circular = delta_phi - tc1_tmp[1]-tc2_tmp[1] # 円軌道での方位角変化
+
+            cc1_tmp = self.ci.circular_curve(R1*phiCC1,\
+                                            R1,\
+                                            tc1_tmp[1]+phiA,\
+                                            R1*phiCC1) # 円軌道
+
+            if(lenTC2>0):
+                tc2_tmp = self.ci.transition_curve(lenTC2,\
+                                              R1,\
+                                              0,\
+                                              cc1_tmp[1]+ tc1_tmp[1]+phiA,\
+                                              tranfunc,\
+                                              lenTC2) # 出口側の緩和曲線
+            else:
+                tc2_tmp=(np.array([0,0]),0,0)
+                
+            if(lenTC3>0):
+                tc3_tmp = self.ci.transition_curve(lenTC3,\
+                                                   0,\
+                                                   R2,\
+                                                   tc2_tmp[1]+cc1_tmp[1]+ tc1_tmp[1]+phiA,\
+                                                   tranfunc,\
+                                                   lenTC3) # 第二曲線入口側の緩和曲線
+            else:
+                tc3_tmp=(np.array([0,0]),0,0)
+                
+            if(lenTC4>0):
+                tc4_tmp = self.ci.transition_curve(lenTC4,\
+                                                   R2,\
+                                                   0,\
+                                                   0,\
+                                                   tranfunc,\
+                                                   lenTC4) # 第二曲線出口側の緩和曲線
+            else:
+                tc4_tmp=(np.array([0,0]),0,0)
+
+            #if (math.angle_twov(phiA,phiB) - (tc1_tmp[1] + tc2_tmp[1] + tc3_tmp[1]))<0:
+            #    raise Exception('invalid R1,R2 pair or too long TC1,2,3')
+
+            phiR1end = tc2_tmp[1] + phiCC1 + tc1_tmp[1]#+phiA
+            phiCC2 = math.angle_twov(phiA,phiB) - (phiR1end + tc3_tmp[1] + tc4_tmp[1])#-phiA
+
+            cc2_tmp = self.ci.circular_curve(R2*phiCC2,\
+                                             R2,\
+                                             tc3_tmp[1]+phiR1end+phiA,\
+                                             R2*phiCC2) # 第二曲線円軌道
+
+
+            res_tmp = A \
+                + tc1_tmp[0] \
+                + cc1_tmp[0] \
+                + tc2_tmp[0] \
+                + lenLint * np.array([np.cos(phiR1end+phiA),np.sin(phiR1end+phiA)]) \
+                + tc3_tmp[0] \
+                + cc2_tmp[0] \
+                + np.dot(self.ci.rotate(phiCC2+tc3_tmp[1]+phiR1end+phiA),tc4_tmp[0])
+
+            # 点Bを通る直線の一般形 ax+by+c=0
+            a = -np.tan(phiB)
+            b = 1
+            c = - a*B[0] - B[1]
+            residual = np.abs(a*res_tmp[0]+b*res_tmp[1]+c)/np.sqrt(a**2+b**2) # 点res_tmpと点Bを通る直線の距離
+        
+            return (res_tmp,residual,tc1_tmp,tc2_tmp,tc3_tmp,cc1_tmp,cc2_tmp,phiCC2)
+        # 点Bを通る直線（x軸との交差角phiB）との距離が最小になる曲線始点をニュートン法で求める
+        num=0 # 繰り返し回数
+        f1 = (np.array([0,0]),error*100)
+        phiCC1 = 0.2 if R1>0 else -0.2
+        while (f1[1] > error and num < num_max):
+            f1 = func(phiCC1,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,R1,R2,tranfunc)
+            df =  (func(phiCC1+dphi,A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,R1,R2,tranfunc)[1]\
+                  -func(phiCC1,     A,phiA,B,phiB,lenTC1,lenTC2,lenTC3,lenTC4,lenLint,R1,R2,tranfunc)[1])/dphi
+
+            phiCC1 = phiCC1 - f1[1]/df
+            #if phiCC1 * R1 < 0 or f1[7] * R2 < 0:
+            #    raise Exception('invalid R1,R2 pair')
+            num +=1
+        return (phiCC1,f1,num)
+
+class IF():
+    def __init__(self,A,B,C,phiA,phiB,phiC,lenTC1,lenTC2,lenTC3,lenTC4,lenCC,lenLint,R_input,R2_input,tranfunc,fitmode,curve_fitmode_box,cursor_obj,cursor_f_name,cursor_t_name,cursor_via_name):
+        self.trackp = curvetrackplot.trackplot()
+        self.sv = solver()
+        
+        self.A = A
+        self.B = B
+        self.C = C
+        self.phiA = phiA
+        self.phiB = phiB
+        self.phiC = phiC
+        self.lenTC1 = lenTC1
+        self.lenTC2 = lenTC2
+        self.lenTC3 = lenTC3
+        self.lenTC4 = lenTC4
+        self.lenCC = lenCC
+        self.lenLint = lenLint
+        self.R_input = R_input
+        self.R2_input = R2_input
+        self.tranfunc = tranfunc
+        self.fitmode = fitmode
+        self.curve_fitmode_box = curve_fitmode_box
+        self.cursor_obj = cursor_obj
+        self.cursor_f_name = cursor_f_name
+        self.cursor_t_name = cursor_t_name
+        self.cursor_via_name = cursor_via_name
+
+        self.cursor_f = self.cursor_obj[self.cursor_f_name]
+        self.cursor_t = self.cursor_obj[self.cursor_t_name]
+        self.cursor_via = self.cursor_obj[self.cursor_via_name]
+    def mode1(self):
+        parameter_str = ''
+        syntax_str = ''
+        
+        self.result = self.sv.curvetrack_fit(self.A,self.phiA,self.B,self.phiB,self.lenTC1,self.lenTC2,self.tranfunc)
+        self.trackp.generate(self.A,self.phiA,self.phiB,self.result[0],self.lenTC1,self.lenTC2,self.tranfunc)
+        self.R_result = self.result[0]
+        self.CCL_result = self.trackp.ccl(self.A,self.phiA,self.phiB,self.result[0],self.lenTC1,self.lenTC2,self.tranfunc)[0]
+        self.shift_result = np.linalg.norm(self.result[1][0] - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.result[1][0] - self.B))
+
+        parameter_str += self.gen_paramstr_mode1_2()
+        syntax_str += self.generate_mapsyntax()
+
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode2(self):
+        parameter_str = ''
+        syntax_str = ''
+        
+        phiA_inv = self.phiA - np.pi if self.phiA>0 else self.phiA + np.pi
+        phiB_inv = self.phiB - np.pi if self.phiB>0 else self.phiB + np.pi
+        self.result = self.sv.curvetrack_fit(self.B,phiB_inv,self.A,phiA_inv,self.lenTC2,self.lenTC1,self.tranfunc)
+        self.trackp.generate(self.B,phiB_inv,phiA_inv,self.result[0],self.lenTC2,self.lenTC1,self.tranfunc)
+        self.R_result = -self.result[0]
+        self.CCL_result = self.trackp.ccl(self.B,phiB_inv,phiA_inv,self.result[0],self.lenTC1,self.lenTC2,self.tranfunc)[0]
+        self.shift_result = np.linalg.norm(self.result[1][0] - self.A)*np.sign(np.dot(np.array([np.cos(self.phiA),np.sin(self.phiA)]),self.result[1][0] - self.A))
+
+        parameter_str += self.gen_paramstr_mode1_2()
+        syntax_str += self.generate_mapsyntax()
+
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode3(self):
+        parameter_str = ''
+        syntax_str = ''
+        
+        self.result = self.sv.curvetrack_relocation(self.A,self.phiA,self.B,self.phiB,self.lenTC1,self.lenTC2,self.tranfunc,self.R_input)
+        self.A_result = self.A + np.array([np.cos(self.phiA),np.sin(self.phiA)])*self.result[0]
+        self.R_result = self.R_input
+        self.trackp.generate(self.A_result,self.phiA,self.phiB,self.R_input,self.lenTC1,self.lenTC2,self.tranfunc)
+        self.CCL_result = self.trackp.ccl(self.A_result,self.phiA,self.phiB,self.R_input,self.lenTC1,self.lenTC2,self.tranfunc)[0]
+        self.shift_result = self.result[0]
+
+        parameter_str += self.gen_paramstr_mode3()
+        syntax_str += self.generate_mapsyntax()
+
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode4_5(self,assigncursor):
+        parameter_str = ''
+        syntax_str = ''
+
+        if self.fitmode.startswith('4.'):
+            self.phi_end = self.phiA + self.lenCC/self.R_input + self.trackp.phi_TC(self.lenTC1, self.R_input, self.tranfunc) + self.trackp.phi_TC(self.lenTC2, self.R_input, self.tranfunc)
+            self.trackp.generate(self.A, self.phiA, self.phi_end, self.R_input, self.lenTC1, self.lenTC2, self.tranfunc)
+        else:
+            self.phi_end = self.phiB - (self.lenCC/self.R_input + self.trackp.phi_TC(self.lenTC1, self.R_input, self.tranfunc) + self.trackp.phi_TC(self.lenTC2, self.R_input, self.tranfunc))
+            self.trackp.generate(self.B, self.phiB + np.pi if self.phiB>0 else self.phiB - np.pi, self.phi_end + np.pi if self.phi_end>0 else self.phi_end - np.pi, -self.R_input, self.lenTC2, self.lenTC1, self.tranfunc)
+        self.R_result = self.R_input
+        self.CCL_result = self.lenCC
+        self.shift_result = 0
+
+        parameter_str += self.gen_paramstr_mode4_5()
+        syntax_str += self.generate_mapsyntax()
+
+        if assigncursor:
+            if self.fitmode.startswith('4.'):
+                tmp_cursor = self.cursor_t
+            elif self.fitmode.startswith('5.'):
+                tmp_cursor = self.cursor_f
+            else:
+                tmp_cursor = None
+            tmp_cursor.values[0].set(self.trackp.result[:,0][-1])
+            tmp_cursor.values[1].set(self.trackp.result[:,1][-1])
+            tmp_cursor.values[2].set(np.rad2deg(self.phi_end))
+            tmp_cursor.values_toshow[0].set('{:.1f}'.format(self.trackp.result[:,0][-1]))
+            tmp_cursor.values_toshow[1].set('{:.1f}'.format(self.trackp.result[:,1][-1]))
+            tmp_cursor.values_toshow[2].set('{:.1f}'.format(np.rad2deg(self.phi_end)))
+            tmp_cursor.marker.set_direct()
+            tmp_cursor.arrow.set_direct()
+
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode6(self):
+        parameter_str = ''
+        syntax_str = ''
+
+        self.result = self.sv.shift_by_TCL(self.A,self.phiA,self.B,self.phiB,self.C,self.tranfunc)
+        self.trackp.generate(self.A,self.phiA,self.phiB,self.result[1][2],self.result[0],self.result[0],self.tranfunc)
+        self.R_result = self.result[1][2]
+        self.CCL_result = self.result[1][1]
+        self.TCL_result = self.result[0]
+        self.endpoint = self.trackp.result[-1]
+        self.shift_result = np.linalg.norm(self.endpoint - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endpoint - self.B))
+
+        parameter_str += self.gen_paramstr_mode6_7()
+        syntax_str += self.generate_mapsyntax()
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode7(self):
+        parameter_str = ''
+        syntax_str = ''
+
+        phiA_inv = self.phiA - np.pi if self.phiA>0 else self.phiA + np.pi
+        phiB_inv = self.phiB - np.pi if self.phiB>0 else self.phiB + np.pi
+        self.result = self.sv.shift_by_TCL(self.B,phiB_inv,self.A,phiA_inv,self.C,self.tranfunc)
+        self.trackp.generate(self.B,phiB_inv,phiA_inv,self.result[1][2],self.result[0],self.result[0],self.tranfunc)
+        self.R_result = -self.result[1][2]
+        self.CCL_result = self.result[1][1]
+        self.TCL_result = self.result[0]
+        self.endpoint = self.trackp.result[-1]
+        self.shift_result = np.linalg.norm(self.endpoint - self.A)*np.sign(np.dot(np.array([np.cos(self.phiA),np.sin(self.phiA)]),self.endpoint - self.A))
+
+        parameter_str += self.gen_paramstr_mode6_7()
+        syntax_str += self.generate_mapsyntax()
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode8(self,withCpos = True):
+        parameter_str = ''
+        syntax_str = ''
+        if False:
+            import pdb
+            pdb.set_trace()
+        if withCpos:
+            self.result = self.sv.reverse_curve(self.A,\
+                                                self.phiA,\
+                                                self.B,\
+                                                self.phiB,\
+                                                self.lenTC1,\
+                                                self.lenTC3,\
+                                                self.lenTC4,\
+                                                self.lenTC2,\
+                                                self.tranfunc,\
+                                                C=self.C,\
+                                                len_interm=self.lenLint)
+        else:
+            self.result = self.sv.reverse_curve(self.A,\
+                                                self.phiA,\
+                                                self.B,\
+                                                self.phiB,\
+                                                self.lenTC1,\
+                                                self.lenTC3,\
+                                                self.lenTC4,\
+                                                self.lenTC2,\
+                                                self.tranfunc,\
+                                                len_interm=self.lenLint)
+
+        self.trackp.generate(self.A,\
+                             self.phiA,\
+                             self.result[4],\
+                             self.result[0][0],\
+                             self.lenTC1,\
+                             self.lenTC3,\
+                             self.tranfunc)
+        self.trackp.generate_add(self.result[3],\
+                                 self.result[4],\
+                                 self.phiB,\
+                                 self.result[1][0],\
+                                 self.lenTC4,\
+                                 self.lenTC2,\
+                                 self.tranfunc)
+
+        self.CCL_result = self.trackp.ccl(self.A,\
+                                          self.phiA,\
+                                          self.result[4],\
+                                          self.result[0][0],\
+                                          self.lenTC1,\
+                                          self.lenTC3,\
+                                          self.tranfunc)[0]
+        self.CCL2_result = self.trackp.ccl(self.result[3],\
+                                           self.result[4],\
+                                           self.phiB,\
+                                           self.result[1][0],\
+                                           self.lenTC4,\
+                                           self.lenTC2,\
+                                           self.tranfunc)[0]
+        self.R1_val = self.result[0][0]
+        self.R2_val = self.result[1][0]
+        self.startPos = self.A
+        self.endPos = self.result[1][1][0]
+
+        self.shift_result = np.linalg.norm(self.endPos - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endPos - self.B))
+
+        parameter_str += self.gen_paramstr_mode8(withCpos=withCpos)
+        syntax_str += self.generate_mapsyntax_reversecurve()
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode9(self,givenR1=False):
+        parameter_str = ''
+        syntax_str = ''
+
+        if False:
+            import pdb
+            pdb.set_trace()
+
+        self.result = self.sv.compound_curve(self.A,\
+                                             self.phiA,\
+                                             self.B,\
+                                             self.phiB,\
+                                             self.C,\
+                                             self.phiC,\
+                                             self.lenTC1,\
+                                             self.lenTC4,\
+                                             self.lenTC2,\
+                                             self.tranfunc,\
+                                             givenR1=self.R_input if givenR1 else None)
+        self.startPos = self.A
+        self.shift_fromA = 0
+        
+        self.R1_val = self.result[3][0]
+        self.R2_val = self.result[1][2][0]
+        self.CCL_result = self.result[0]
+        self.CCL2_result = self.trackp.ccl(self.result[1][1][0], self.result[1][1][1], self.phiB, self.result[1][2][0], self.lenTC4, self.lenTC2, self.tranfunc, R0 = self.result[3][0])[0]
+        self.endpos = self.result[1][2][1][0]
+        self.shift_result = np.linalg.norm(self.endpos - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endpos - self.B))
+
+        self.trackp.generate(self.startPos,\
+                             self.phiA,\
+                             self.result[1][1][1],\
+                             self.result[3][0],\
+                             self.lenTC1,0,\
+                             self.tranfunc)
+        self.trackp.generate_add(self.result[1][1][0],\
+                                 self.result[1][1][1],\
+                                 self.phiB,\
+                                 self.result[1][2][0],\
+                                 self.lenTC4,\
+                                 self.lenTC2,\
+                                 self.tranfunc,\
+                                 R0 = self.result[3][0])
+
+        parameter_str += self.gen_paramstr_mode9(givenR=givenR1)
+        syntax_str += self.generate_mapsyntax_compoundcurve()
+        
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode10(self): # 8-4
+        parameter_str = ''
+        syntax_str = ''
+
+        self.result_R1 = self.sv.curvetrack_relocation(self.A,\
+                                                       self.phiA,\
+                                                       self.C,\
+                                                       self.phiC,\
+                                                       self.lenTC1,\
+                                                       self.lenTC3,\
+                                                       self.tranfunc,\
+                                                       self.R_input)
+
+        self.Cdash = self.result_R1[1][0]
+
+        self.result_R2 = self.sv.curvetrack_relocation(self.Cdash,\
+                                                       self.phiC,\
+                                                       self.B,\
+                                                       self.phiB,\
+                                                       self.lenTC4,\
+                                                       self.lenTC2,\
+                                                       self.tranfunc,\
+                                                       self.R2_input)
+
+        if self.result_R2[0] < 0:
+            raise Exception('invalid parameters')
+
+        self.A_result = self.A + self.result_R1[0]*np.array([np.cos(self.phiA),np.sin(self.phiA)])
+        self.C_result = self.Cdash + self.result_R2[0]*np.array([np.cos(self.phiC),np.sin(self.phiC)])
+        self.CCL_result  = self.trackp.ccl(self.A_result,self.phiA,self.phiC,self.R_input ,self.lenTC1,self.lenTC3,self.tranfunc)[0]
+        self.CCL2_result = self.trackp.ccl(self.C_result,self.phiC,self.phiB,self.R2_input,self.lenTC4,self.lenTC2,self.tranfunc)[0]
+        self.lenLint = self.result_R2[0]
+        self.shift_result = self.result_R1[0]
+        self.R1_val = self.R_input
+        self.R2_val = self.R2_input
+        self.endPos = self.result_R2[0]
+
+        
+        self.trackp.generate(self.A_result,\
+                             self.phiA,\
+                             self.phiC,\
+                             self.R_input,\
+                             self.lenTC1,\
+                             self.lenTC3,\
+                             self.tranfunc)
+        self.trackp.generate_add(self.C_result,\
+                                 self.phiC,\
+                                 self.phiB,\
+                                 self.R2_input,\
+                                 self.lenTC4,\
+                                 self.lenTC2,\
+                                 self.tranfunc)
+
+
+        syntax_str = self.generate_mapsyntax_reversecurve(initial_shift = True)
+        parameter_str = self.gen_paramstr_mode8(endpos=False,givenR=True,givenR2=True,givenLint=False)
+        
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode11(self): # 9-3
+        if False:
+            import pdb
+            pdb.set_trace()
+        parameter_str = ''
+        syntax_str = ''
+        self.result = self.sv.compound_curve_givenR(self.A,self.phiA,self.B,self.phiB,self.lenTC1,self.lenTC4,self.lenTC2,self.R_input,self.R2_input,self.tranfunc)
+
+        self.trackp.generate(self.A,\
+                             self.phiA,self.result[0]+self.result[1][2][1]+self.phiA,self.R_input,self.lenTC1,0,self.tranfunc)
+        self.trackp.generate_add(self.A + self.result[1][2][0] + self.result[1][5][0],\
+                                 self.result[0]+self.result[1][2][1]+self.phiA,self.phiB,self.R2_input,self.lenTC4,self.lenTC2,self.tranfunc,R0=self.R_input)
+        
+        self.startPos = self.A
+        self.shift_fromA = 0
+
+        self.R1_val = self.R_input
+        self.R2_val = self.R2_input
+        self.CCL_result = self.R1_val * self.result[0]
+        self.CCL2_result = self.R2_val * self.result[1][6][1]
+        self.endpos = self.result[1][0]
+        self.shift_result = np.linalg.norm(self.endpos - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endpos - self.B))
+
+        syntax_str = self.generate_mapsyntax_compoundcurve()
+        parameter_str = self.gen_paramstr_mode9(givenR=True,givenR2=True)
+
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode12(self): # 8-3
+        ''' mode 9-2 + L_intermediate
+        '''
+        if False:
+            import pdb
+            pdb.set_trace()
+            
+        parameter_str = ''
+        syntax_str = ''
+
+        self.result = self.sv.compound_curve_Linterm(self.A,\
+                                                     self.phiA,\
+                                                     self.B,\
+                                                     self.phiB,\
+                                                     self.C,\
+                                                     self.phiC,\
+                                                     self.lenTC1,\
+                                                     self.lenTC3,\
+                                                     self.lenTC4,\
+                                                     self.lenTC2,\
+                                                     self.lenLint,\
+                                                     self.tranfunc,\
+                                                     givenR1=self.R_input)
+        self.startPos = self.A
+        self.shift_fromA = 0
+        
+        self.R1_val = self.result[3][0]
+        self.R2_val = self.result[1][2][0]
+        self.CCL_result = self.result[0]
+        self.CCL2_result = self.trackp.ccl(self.result[1][1][0], self.result[1][1][1], self.phiB, self.result[1][2][0], self.lenTC4, self.lenTC2, self.tranfunc)[0]
+        self.endPos = self.result[1][2][1][0]
+        self.shift_result = np.linalg.norm(self.endPos - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endPos - self.B))
+
+        self.trackp.generate(self.startPos,\
+                             self.phiA,\
+                             self.result[1][1][1],\
+                             self.R1_val,\
+                             self.lenTC1,\
+                             self.lenTC3,\
+                             self.tranfunc)
+        self.trackp.generate_add(self.result[1][3][0],\
+                                 self.result[1][3][1],\
+                                 self.phiB,\
+                                 self.R2_val,\
+                                 self.lenTC4,\
+                                 self.lenTC2,\
+                                 self.tranfunc)
+
+        parameter_str += self.gen_paramstr_mode8(withCpos=False,givenR=True)
+        syntax_str += self.generate_mapsyntax_reversecurve()
+        
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode13(self): # 8-4
+        ''' mode 9-3 + L_intermediate
+        '''
+        if False:
+            import pdb
+            pdb.set_trace()
+            
+        parameter_str = ''
+        syntax_str = ''
+
+        self.result = self.sv.compound_curve_givenR_Lint(self.A,\
+                                                         self.phiA,\
+                                                         self.B,\
+                                                         self.phiB,\
+                                                         self.lenTC1,\
+                                                         self.lenTC3,\
+                                                         self.lenTC4,\
+                                                         self.lenTC2,\
+                                                         self.lenLint,\
+                                                         self.R_input,\
+                                                         self.R2_input,\
+                                                         self.tranfunc,)
+        self.startPos = self.A
+        self.shift_fromA = 0
+
+        self.R1_val = self.R_input
+        self.R2_val = self.R2_input
+        self.CCL_result = self.R1_val * self.result[0]
+        self.CCL2_result = self.R2_val * self.result[1][6][1]
+        self.endPos = self.result[1][0]
+        self.shift_result = np.linalg.norm(self.endPos - self.B)*np.sign(np.dot(np.array([np.cos(self.phiB),np.sin(self.phiB)]),self.endPos - self.B))
+
+        phiR1end = self.result[1][3][1]+self.result[0]+self.result[1][2][1]+self.phiA
+        
+        self.trackp.generate(self.startPos,\
+                             self.phiA,\
+                             phiR1end,\
+                             self.R1_val,\
+                             self.lenTC1,\
+                             self.lenTC3,\
+                             self.tranfunc)
+        self.trackp.generate_add(self.result[1][2][0]+self.result[1][5][0]+self.result[1][3][0]+ self.lenLint * np.array([np.cos(phiR1end),np.sin(phiR1end)])+self.A,\
+                                 phiR1end,\
+                                 self.phiB,\
+                                 self.R2_val,\
+                                 self.lenTC4,\
+                                 self.lenTC2,\
+                                 self.tranfunc)
+
+        parameter_str += self.gen_paramstr_mode8(withCpos=False,givenR=True,givenR2=True)
+        syntax_str += self.generate_mapsyntax_reversecurve()
+        
+        return {'track':self.trackp.result, 'param':parameter_str, 'syntax':syntax_str}
+    def mode9_12(self,givenR1=False): # 8-3, 9-2
+        if self.lenLint == 0:
+            result=self.mode9(givenR1=givenR1)
+        else:
+            result=self.mode12()
+        return result
+    def mode11_13(self): # 8-4, 9-3
+        if self.lenLint == 0:
+            result=self.mode11()
+        else:
+            result=self.mode13()
+        return result
+    def generate_mapsyntax(self):
+        syntax_str = ''
+        syntax_str += '$pt_a = {:f};'.format(self.cursor_f.values[4].get() if self.cursor_f.values[3].get() != '@absolute' else 0) + '\n'
+        if self.fitmode.startswith('1.') or self.fitmode.startswith('6.'):
+            shift = 0
+            syntax_str += '$pt_a;' + '\n'
+        else:
+            shift = self.shift_result
+            syntax_str += '$pt_a {:s}{:f};'.format('+' if shift>=0 else '',shift) + '\n'
+        syntax_str += '$cant = 0;' + '\n'
+        syntax_str += 'Curve.SetFunction({:d});'.format(0 if self.tranfunc == 'sin' else 1) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        if self.fitmode.startswith('6.') or self.fitmode.startswith('7.'):
+            lenTC_result = {'1':self.TCL_result, '2':self.TCL_result}
+        else:
+            lenTC_result = {'1':self.lenTC1, '2':self.lenTC2}
+        if lenTC_result['1'] != 0 or True:
+            tmp = shift + lenTC_result['1']
+            syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R_result) + '\n'
+        tmp = (shift + lenTC_result['1'] + self.CCL_result)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R_result) + '\n'
+        if lenTC_result['2'] != 0 or True:
+            tmp = (shift + lenTC_result['1'] + self.CCL_result + lenTC_result['2'])
+            syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        
+        return syntax_str
+    def generate_mapsyntax_reversecurve(self,initial_shift=None):
+        syntax_str = ''
+        syntax_str += '$pt_a = {:f};'.format(self.cursor_f.values[4].get() \
+                                             if self.cursor_f.values[3].get() != '@absolute' else 0) + '\n'
+        if initial_shift is None:
+            shift = 0
+            syntax_str += '$pt_a;' + '\n'
+        else:
+            shift = self.shift_result
+            tmp = shift
+            syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += '$cant = 0;' + '\n'
+        syntax_str += 'Curve.SetFunction({:d});'.format(0 if self.tranfunc == 'sin' else 1) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        
+        tmp = shift + self.lenTC1
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R1_val) + '\n'
+        
+        tmp = (shift + self.lenTC1 + self.CCL_result)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R1_val) + '\n'
+        
+        tmp = (shift + self.lenTC1 + self.CCL_result + self.lenTC3)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        syntax_str += '\n'
+
+        end_R1 = shift + self.lenTC1 + self.CCL_result + self.lenTC3 + self.lenLint
+        tmp = end_R1
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += '$cant = 0;' + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+
+        tmp = end_R1 + self.lenTC4
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R2_val) + '\n'
+        
+        tmp = (end_R1 + self.lenTC4 + self.CCL2_result)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R2_val) + '\n'
+        
+        tmp = (end_R1 + self.lenTC4 + self.CCL2_result + self.lenTC2)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        
+        return syntax_str
+    def generate_mapsyntax_compoundcurve(self):
+        syntax_str = ''
+        syntax_str += '$pt_a = {:f};'.format(self.cursor_f.values[4].get() \
+                                             if self.cursor_f.values[3].get() != '@absolute' else 0) + '\n'
+        shift = self.shift_fromA
+        syntax_str += '$pt_a;' + '\n'
+        syntax_str += '$cant = 0;' + '\n'
+        syntax_str += 'Curve.SetFunction({:d});'.format(0 if self.tranfunc == 'sin' else 1) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        
+        tmp = shift + self.lenTC1
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R1_val) + '\n'
+        
+        tmp = (shift + self.lenTC1 + self.CCL_result)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R1_val) + '\n'
+
+        end_R1 = shift + self.lenTC1 + self.CCL_result + self.lenTC4
+        tmp = end_R1
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += '$cant = 0;' + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R2_val) + '\n'
+        
+        tmp = (end_R1  + self.CCL2_result)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f}, $cant);'.format(self.R2_val) + '\n'
+        
+        tmp = (end_R1  + self.CCL2_result + self.lenTC2)
+        syntax_str += '$pt_a {:s}{:f};'.format('+' if tmp>=0 else '', tmp) + '\n'
+        syntax_str += 'Curve.Interpolate({:f},0);'.format(0) + '\n'
+        
+        return syntax_str
+    def gen_paramstr_mode1_2(self):
+        parameter_str = ''
+
+        parameter_str += '[Curve fitting]\n'
+        parameter_str += 'Inputs:\n'
+        parameter_str += '   Fitmode:          {:s}\n'.format(self.fitmode)
+        parameter_str += '   Cursor α,β:       {:s},{:s}\n'.format(self.cursor_f_name,self.cursor_t_name)
+        parameter_str += '   Ponint α:         ({:f}, {:f})\n'.format(self.A[0],self.A[1])
+        parameter_str += '   Ponint β:         ({:f}, {:f})\n'.format(self.B[0],self.B[1])
+        parameter_str += '   Direction α:     {:f}\n'.format(self.cursor_f.values[2].get())
+        parameter_str += '   Direction β:     {:f}\n'.format(self.cursor_t.values[2].get())
+        parameter_str += '   Transition func.: {:s}\n'.format(self.tranfunc)
+        parameter_str += '   TCL α:            {:f}\n'.format(self.lenTC1)
+        parameter_str += '   TCL β:            {:f}\n'.format(self.lenTC2)            
+        parameter_str += 'Results:\n'
+        parameter_str += '   R:   {:f}\n'.format(self.R_result)
+        parameter_str += '   CCL: {:f}\n'.format(self.CCL_result)
+        parameter_str += '   endpt:            ({:f}, {:f})\n'.format(self.result[1][0][0],self.result[1][0][1])
+        parameter_str += '   shift from pt. β: {:f}\n'.format(self.shift_result)
+        if self.fitmode.startswith('1.'):
+            parameter_str += '   endpt:            ({:f}, {:f})'.format(self.result[1][0][0],self.result[1][0][1]) + '\n'
+            parameter_str += '   shift from pt. β: {:f}'.format(self.shift_result) + '\n'
+        else:
+            parameter_str += '   startpt:          ({:f}, {:f})'.format(self.result[1][0][0],self.result[1][0][1]) + '\n'
+            parameter_str += '   shift from pt. α: {:f}'.format(self.shift_result) + '\n'
+
+        return parameter_str
+    def gen_paramstr_mode3(self):
+        parameter_str = ''
+
+        parameter_str += '[Curve fitting]' + '\n'
+        parameter_str += 'Inputs:' + '\n'
+        parameter_str += '   Fitmode:          {:s}'.format(self.fitmode) + '\n'
+        parameter_str += '   Cursor α,β:       {:s},{:s}'.format(self.cursor_f_name,self.cursor_t_name) + '\n'
+        parameter_str += '   Ponint α:         ({:f}, {:f})'.format(self.A[0],self.A[1]) + '\n'
+        parameter_str += '   Ponint β:         ({:f}, {:f})'.format(self.B[0],self.B[1]) + '\n'
+        parameter_str += '   Direction α:     {:f}'.format(self.cursor_f.values[2].get()) + '\n'
+        parameter_str += '   Direction β:     {:f}'.format(self.cursor_t.values[2].get()) + '\n'
+        parameter_str += '   Transition func.: {:s}'.format(self.tranfunc) + '\n'
+        parameter_str += '   TCL α:            {:f}'.format(self.lenTC1) + '\n'
+        parameter_str += '   TCL β:            {:f}'.format(self.lenTC2) + '\n'
+        parameter_str += '   R:                {:f}'.format(self.R_input) + '\n'
+        parameter_str += 'Results:' + '\n'
+        parameter_str += '   CCL:        {:f}'.format(self.CCL_result) + '\n'
+        parameter_str += '   startpoint: ({:f}, {:f})'.format(self.A_result[0],self.A_result[1]) + '\n'
+        parameter_str += '   shift:      {:f}'.format(self.shift_result) + '\n'
+        return parameter_str
+    def gen_paramstr_mode4_5(self):
+        parameter_str = ''
+        cursor_label = 'α' if self.fitmode.startswith('4.') else 'β'
+        
+        parameter_str += '[Curve fitting]' + '\n'
+        parameter_str += 'Inputs:' + '\n'
+        parameter_str += '   Fitmode:          {:s}'.format(self.fitmode) + '\n'
+        parameter_str += '   Cursor {:s}:         {:s}'.format(cursor_label,self.cursor_f_name) + '\n'
+        parameter_str += '   Ponint {:s}:         ({:f}, {:f})'.format(cursor_label,self.A[0],self.A[1]) + '\n'
+        parameter_str += '   Direction {:s}:      {:f}'.format(cursor_label,self.cursor_f.values[2].get()) + '\n'
+        parameter_str += '   Transition func.: {:s}'.format(self.tranfunc) + '\n'
+        parameter_str += '   TCL α:            {:f}'.format(self.lenTC1) + '\n'
+        parameter_str += '   TCL β:            {:f}'.format(self.lenTC2) + '\n'
+        parameter_str += '   CCL:              {:f}'.format(self.CCL_result) + '\n'
+        parameter_str += '   R:                {:f}'.format(self.R_input) + '\n'
+        parameter_str += 'Results:' + '\n'
+        if self.fitmode.startswith('4.'):
+            parameter_str += '   endpoint: ({:f}, {:f})'.format(self.trackp.result[:,0][-1],self.trackp.result[:,1][-1]) + '\n'
+            parameter_str += '   phi_end:  {:f}'.format(np.rad2deg(self.phi_end)) + '\n'
+
+        else:
+            parameter_str += '   startpoint: ({:f}, {:f})'.format(self.trackp.result[:,0][-1],self.trackp.result[:,1][-1]) + '\n'
+            parameter_str += '   phi_start:  {:f}'.format(np.rad2deg(self.phi_end)) + '\n'
+        return parameter_str
+    def gen_paramstr_mode6_7(self):
+        parameter_str = ''
+        parameter_str += '[Curve fitting]' + '\n'
+        parameter_str += 'Inputs:' +'\n'
+        parameter_str += '   Fitmode:          {:s}'.format(self.fitmode) +'\n'
+        parameter_str += '   Cursor α,β,γ:     {:s},{:s},{:s}'.format(self.cursor_f_name,self.cursor_t_name,self.cursor_via_name) +'\n'
+        parameter_str += '   Ponint α:         ({:f}, {:f})'.format(self.A[0],self.A[1]) +'\n'
+        parameter_str += '   Ponint β:         ({:f}, {:f})'.format(self.B[0],self.B[1]) +'\n'
+        parameter_str += '   Ponint γ:         ({:f}, {:f})'.format(self.C[0],self.C[1]) +'\n'
+        parameter_str += '   Direction α:     {:f}'.format(self.cursor_f.values[2].get()) +'\n'
+        parameter_str += '   Direction β:     {:f}'.format(self.cursor_t.values[2].get()) +'\n'
+        parameter_str += '   Transition func.: {:s}'.format(self.tranfunc) +'\n'          
+        parameter_str += 'Results:' +'\n'
+        parameter_str += '   R:   {:f}'.format(self.R_result) +'\n'
+        parameter_str += '   CCL: {:f}'.format(self.CCL_result) +'\n'
+        parameter_str += '   TCL: {:f}'.format(self.TCL_result) +'\n'
+        if '6.' in self.fitmode:
+            #endpoint = self.trackp.result[-1]
+            parameter_str += '   endpt:            ({:f}, {:f})'.format(self.endpoint[0],self.endpoint[1]) +'\n'
+            parameter_str += '   shift from pt. β: {:f}'.format(self.shift_result) +'\n'
+        else:
+            parameter_str += '   startpt:          ({:f}, {:f})'.format(self.endpoint[0],self.endpoint[1]) +'\n'
+            parameter_str += '   shift from pt. α: {:f}'.format(self.shift_result) +'\n'
+        return parameter_str
+    def gen_paramstr_mode8(self,withCpos=True,endpos=True,givenR=False,givenR2=False,givenLint=True):
+        parameter_str = ''
+
+        parameter_str += '[Curve fitting]' + '\n'
+        parameter_str += 'Inputs:' + '\n'
+        parameter_str += '   Fitmode:          {:s}'.format(self.fitmode) + '\n'
+        parameter_str += '   Cursor α,β,γ:     {:s},{:s},{:s}'.format(self.cursor_f_name,self.cursor_t_name,self.cursor_via_name) + '\n'
+        parameter_str += '   Ponint α:         ({:f}, {:f})'.format(self.A[0],self.A[1]) + '\n'
+        parameter_str += '   Ponint β:         ({:f}, {:f})'.format(self.B[0],self.B[1]) + '\n'
+        if withCpos:
+            parameter_str += '   Ponint γ:         ({:f}, {:f})'.format(self.C[0],self.C[1]) + '\n'
+        parameter_str += '   Direction α:      {:f}'.format(self.cursor_f.values[2].get()) + '\n'
+        parameter_str += '   Direction β:      {:f}'.format(self.cursor_t.values[2].get()) + '\n'
+        parameter_str += '   Transition func.: {:s}'.format(self.tranfunc) + '\n'
+        parameter_str += '   TCLα:             {:f}'.format(self.lenTC1) + '\n'
+        parameter_str += '   TCLγ:             {:f}'.format(self.lenTC3) + '\n'
+        parameter_str += '   TCLδ:             {:f}'.format(self.lenTC4) + '\n'
+        parameter_str += '   TCLβ:             {:f}'.format(self.lenTC2) + '\n'
+        if givenLint:
+            parameter_str += '   L intermediate:   {:f}'.format(self.lenLint) + '\n'
+        if givenR:
+            parameter_str += '   R1:               {:f}'.format(self.R1_val) + '\n'
+        if givenR2:
+            parameter_str += '   R2:               {:f}'.format(self.R2_val) + '\n'
+        parameter_str += 'Results:' + '\n'
+        if givenR is False:
+            parameter_str += '   R1:        {:f}'.format(self.R1_val) + '\n'
+        if givenR2 is False:
+            parameter_str += '   R2:        {:f}'.format(self.R2_val) + '\n'
+        if givenLint is False:
+            parameter_str += '   L int.:    {:f}'.format(self.lenLint) + '\n'
+        parameter_str += '   CCL1:      {:f}'.format(self.CCL_result) + '\n'
+        parameter_str += '   CCL2:      {:f}'.format(self.CCL2_result) + '\n'
+        if endpos:
+            parameter_str += '   endpt:     ({:f}, {:f})\n'.format(self.endPos[0],self.endPos[1])
+            parameter_str += '   shift from pt. β: {:f}\n'.format(self.shift_result)
+        else:
+            parameter_str += '   startpt:   ({:f}, {:f})\n'.format(self.A_result[0],self.A_result[1])
+            parameter_str += '   shift from pt. α: {:f}\n'.format(self.shift_result)
+        return parameter_str
+    def gen_paramstr_mode9(self,givenR=False,givenR2=False):
+        parameter_str = ''
+
+        parameter_str += '[Curve fitting]' + '\n'
+        parameter_str += 'Inputs:' + '\n'
+        parameter_str += '   Fitmode:          {:s}'.format(self.fitmode) + '\n'
+        parameter_str += '   Cursor α,β,γ:     {:s},{:s},{:s}'.format(self.cursor_f_name,self.cursor_t_name,self.cursor_via_name) + '\n'
+        parameter_str += '   Ponint α:         ({:f}, {:f})'.format(self.A[0],self.A[1]) + '\n'
+        parameter_str += '   Ponint β:         ({:f}, {:f})'.format(self.B[0],self.B[1]) + '\n'
+        parameter_str += '   Ponint γ:         ({:f}, {:f})'.format(self.C[0],self.C[1]) + '\n'
+        parameter_str += '   Direction α:      {:f}'.format(self.cursor_f.values[2].get()) + '\n'
+        parameter_str += '   Direction β:      {:f}'.format(self.cursor_t.values[2].get()) + '\n'
+        parameter_str += '   Direction γ:      {:f}'.format(self.cursor_via.values[2].get()) + '\n'
+        parameter_str += '   Transition func.: {:s}'.format(self.tranfunc) + '\n'
+        parameter_str += '   TCLα:             {:f}'.format(self.lenTC1) + '\n'
+        parameter_str += '   TCLδ:             {:f}'.format(self.lenTC4) + '\n'
+        #parameter_str += '   TCL3:             {:f}'.format(self.lenTC3) + '\n'
+        parameter_str += '   TCLβ:             {:f}'.format(self.lenTC2) + '\n'
+        parameter_str += '   L intermediate:   {:f}'.format(self.lenLint) + '\n'
+        if givenR:
+            parameter_str += '   R1:               {:f}'.format(self.R1_val) + '\n'
+        if givenR2:
+            parameter_str += '   R2:               {:f}'.format(self.R2_val) + '\n'
+        parameter_str += 'Results:' + '\n'
+        if givenR is False:
+            parameter_str += '   R1:        {:f}'.format(self.R1_val) + '\n'
+        if givenR2 is False:
+            parameter_str += '   R2:        {:f}'.format(self.R2_val) + '\n'
+        parameter_str += '   CCL1:      {:f}'.format(self.CCL_result) + '\n'
+        parameter_str += '   CCL2:      {:f}'.format(self.CCL2_result) + '\n'
+        parameter_str += '   endpt:     ({:f}, {:f})\n'.format(self.endpos[0],self.endpos[1])
+        parameter_str += '   shift from pt. α: {:f}\n'.format(self.shift_fromA)
+        parameter_str += '   shift from pt. β: {:f}\n'.format(self.shift_result)
+        return parameter_str
```

## Comparing `tsutsuji_trackcomputer-1.5.4.dist-info/LICENSE` & `tsutsuji_trackcomputer-1.6.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tsutsuji_trackcomputer-1.5.4.dist-info/METADATA` & `tsutsuji_trackcomputer-1.6.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: tsutsuji-trackcomputer
-Version: 1.5.4
+Version: 1.6.0
 Summary: Track building helper for Bve trainsim 5/6
 Home-page: https://github.com/konawasabi/tsutsuji-trackcomputer/
 Author: Konawasabi
 Author-email: webmaster@konawasabi.riceball.jp
 License: Apache License 2.0
 Keywords: BVE trainsim
 Description-Content-Type: text/markdown
@@ -16,38 +16,38 @@
 
 Bve trainsim 5/6向けマップファイルの制作支援Pythonスクリプトです。
 全ての軌道を自軌道構文で記述し、一つの軌道を基準とした他軌道構文に変換するのが主な機能です。
 まだ開発途上ですが、軌道データ作成に役立つ測量機能も付属しています。
 
 ## インストール
 
-動作に必要な環境
-
-- [Python 3](https://www.python.org/downloads/)
-- [Kobushi trackviewer](https://github.com/konawasabi/kobushi-trackviewer) Ver1.1.4以降
-- [numpy](https://numpy.org)
-- [matplotlib](https://matplotlib.org)
-- [scipy](https://www.scipy.org)
-- [lark](https://lark-parser.readthedocs.io/en/latest/)
-- [ttkwidgets](https://ttkwidgets.readthedocs.io/en/latest/)
-- [requests](https://requests-docs-ja.readthedocs.io/en/latest/)
-
 インストールするには、Python 3をインストールしてからPowershellで次のコマンドを実行してください。
 Tsutsuji本体と、動作に必要なパッケージが自動でインストールされます。
 ```
 pip install tsutsuji-trackcomputer
 ```
 
 なお、https://konawasabi.riceball.jp/2022/06/01/tsutsuji-kobushi-installguide/ にて、Python3のセットアップを含めたインストール手順の説明をしていますので、参考にしてもらえればと思います。
 
 インストール済みのTsutsuji, Kobushiをバージョンアップする際は、次のコマンドを実行してください。
 ```
 pip install --upgrade tsutsuji-trackcomputer kobushi-trackviewer
 ```
 
+### 動作に必要な環境
+
+- [Python 3](https://www.python.org/downloads/)
+- [Kobushi trackviewer](https://github.com/konawasabi/kobushi-trackviewer) Ver1.1.4以降
+- [numpy](https://numpy.org)
+- [matplotlib](https://matplotlib.org)
+- [scipy](https://www.scipy.org)
+- [lark](https://lark-parser.readthedocs.io/en/latest/)
+- [ttkwidgets](https://ttkwidgets.readthedocs.io/en/latest/)
+- [requests](https://requests-docs-ja.readthedocs.io/en/latest/)
+
 ## 起動
 
 Tsutsujiは次のコマンドで起動できます。
 
 ```
 python -m tsutsuji
 ```
```

## Comparing `tsutsuji_trackcomputer-1.5.4.dist-info/RECORD` & `tsutsuji_trackcomputer-1.6.0.dist-info/RECORD`

 * *Files 26% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 tsutsuji/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tsutsuji/__main__.py,sha256=7Gk_TYmLmfVa9AdkoLxZE8B46Qg3mou2ijm6dpmU8CM,647
-tsutsuji/_version.py,sha256=J1aSCJ_LeXu9eC8GJfi0qc4dCnumcuDr3J7ga_AZg8g,22
+tsutsuji/_version.py,sha256=bYN93DTWr8alkTnO3wj31CU5gqTshxIcsbXUcJcUAc8,22
 tsutsuji/backimg.py,sha256=NCpPyjXcG-sZ5dI4URb8MePcxfWUa6MgtINHW13E740,26141
 tsutsuji/config.py,sha256=cCqC_9R7D7SxvlGq4fGnNzbOAPQCMOfSYPGQLXfX2c4,5514
 tsutsuji/cui2.py,sha256=spk94smgq-bPZCFfT5wblgNY-o5Ir7mZ6Hx-7E9Zspw,2155
-tsutsuji/curvetrackplot.py,sha256=cqI9ZxfJ7k1VCdFLPCMDL2vz-xkqy1k3ya89jr5D20Y,4040
+tsutsuji/curvetrackplot.py,sha256=2XH3sqzdWKamAjDjdVb9xTfsZU0j24k7UUgew1HE9PQ,5753
 tsutsuji/drawcursor.py,sha256=1pmDNX4KFZx6-He3kGh5ONkYIxB-nabl2TiWLk-yocU,17026
 tsutsuji/gui_tsutsuji.py,sha256=76-f718L0JGYSO5W3DsY_fwR583cak_71zP6BVCzoT4,19787
 tsutsuji/kml2track.py,sha256=uJtPMpgi3t2ljZhUkyWj2B2j6jAB3h_tHjwfaFfoDQs,5060
 tsutsuji/kp_offset.py,sha256=JQw1YrfCk81_Xbxa1QycMmQGCnbMiuXtaHxsMg6D4Vw,5551
-tsutsuji/math.py,sha256=zumMofhCbqijALctlZvq5X4v8JbaEjHc37LMQ14en4o,12989
-tsutsuji/measure.py,sha256=XqBTX2WYMbpvrinhjN3RAh7lpPrztpWSfWM9wRGklnI,37896
-tsutsuji/solver.py,sha256=AMgm2fg3VB6Xfxq406iEv4qkZFpCNsaNAZiABje9YTk,8619
+tsutsuji/math.py,sha256=m-BN4gritBsqiAcfJTp4G3sXCrGcY2IemHCiZlNLDgQ,13102
+tsutsuji/measure.py,sha256=1oCB2nuzpg3CGVUbqlQYr7NygsYlBofuBNMHVNyh7gs,28724
+tsutsuji/solver.py,sha256=Sa4eM5MAIUbsCdQ8AJ_tf7plzkLoIN1wX6ktDZSVS5k,69046
 tsutsuji/track_control.py,sha256=HaGJbMQMyc3oypuwzT-wx1FUDwgGONVeKB0JdtUzP4o,34854
 tsutsuji/trackwindow.py,sha256=c2c1bsR2AIwqWCEwjPVnMkwLWgJbjpng8Xpso6pHhzU,10318
-tsutsuji_trackcomputer-1.5.4.dist-info/LICENSE,sha256=F1Ts-WBWMCb_LIZ9VTntNMKH8rjOlcBwWWGRItqwCrs,9723
-tsutsuji_trackcomputer-1.5.4.dist-info/METADATA,sha256=bKKOmyvS27UHx0FXQpsvW065bl6INuQ9rw-ksk9l4sQ,3464
-tsutsuji_trackcomputer-1.5.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-tsutsuji_trackcomputer-1.5.4.dist-info/top_level.txt,sha256=-4EP2VNLqJy2zJugsOEOF9q-Ir7baVH8QYXuuNtm_0s,9
-tsutsuji_trackcomputer-1.5.4.dist-info/RECORD,,
+tsutsuji_trackcomputer-1.6.0.dist-info/LICENSE,sha256=F1Ts-WBWMCb_LIZ9VTntNMKH8rjOlcBwWWGRItqwCrs,9723
+tsutsuji_trackcomputer-1.6.0.dist-info/METADATA,sha256=JcYVCzKQmJ6FzBwUm8k57_B08r886cbRN4FsoVbroNg,3468
+tsutsuji_trackcomputer-1.6.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+tsutsuji_trackcomputer-1.6.0.dist-info/top_level.txt,sha256=-4EP2VNLqJy2zJugsOEOF9q-Ir7baVH8QYXuuNtm_0s,9
+tsutsuji_trackcomputer-1.6.0.dist-info/RECORD,,
```

